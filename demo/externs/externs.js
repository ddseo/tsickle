/**
 * @externs
 * @suppress {checkTypes,const,duplicate,missingOverride}
 */
// NOTE: generated by tsickle, do not edit.
// Generated from: immutable.d.ts
/** @const */
var immutable_ = {};
/** @const */
immutable_.Immutable = {};

/**
 * True if the provided value is a List
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable');
 * List.isList([]); // false
 * List.isList(List()); // true
 * ```
 * @param {*} maybeList
 * @return {boolean}
 */
immutable_.Immutable.List.isList = function(maybeList) {};

/**
 * Creates a new List containing `values`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable');
 * List.of(1, 2, 3, 4)
 * // List [ 1, 2, 3, 4 ]
 * ```
 * 
 * Note: Values are not altered or converted in any way.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable');
 * List.of({x:1}, 2, [3], 4)
 * // List [ { x: 1 }, 2, [ 3 ], 4 ]
 * ```
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.List.of = function(values) {};

/**
 * Create a new immutable List containing the values of the provided
 * collection-like.
 * 
 * Note: `List` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List, Set } = require('immutable')
 * 
 * const emptyList = List()
 * // List []
 * 
 * const plainArray = [ 1, 2, 3, 4 ]
 * const listFromPlainArray = List(plainArray)
 * // List [ 1, 2, 3, 4 ]
 * 
 * const plainSet = Set([ 1, 2, 3, 4 ])
 * const listFromPlainSet = List(plainSet)
 * // List [ 1, 2, 3, 4 ]
 * 
 * const arrayIterator = plainArray[Symbol.iterator]()
 * const listFromCollectionArray = List(arrayIterator)
 * // List [ 1, 2, 3, 4 ]
 * 
 * listFromPlainArray.equals(listFromCollectionArray) // true
 * listFromPlainSet.equals(listFromCollectionArray) // true
 * listFromPlainSet.equals(listFromPlainArray) // true
 * ```
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.List = function(collection) {};
/** @type {number} */
immutable_.Immutable.List.prototype.size;

/**
 * Returns a new List which includes `value` at `index`. If `index` already
 * exists in this List, it will be replaced.
 * 
 * `index` may be a negative number, which indexes back from the end of the
 * List. `v.set(-1, "value")` sets the last item in the List.
 * 
 * If `index` larger than `size`, the returned List's `size` will be large
 * enough to include the `index`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * const originalList = List([ 0 ]);
 * // List [ 0 ]
 * originalList.set(1, 1);
 * // List [ 0, 1 ]
 * originalList.set(0, 'overwritten');
 * // List [ "overwritten" ]
 * originalList.set(2, 2);
 * // List [ 0, undefined, 2 ]
 * 
 * List().set(50000, 'value').size;
 * // 50001
 * ```
 * 
 * Note: `set` can be used in `withMutations`.
 * @public
 * @param {number} index
 * @param {T} value
 * @return {?}
 */
immutable_.Immutable.List.prototype.set = function(index, value) {};

/**
 * Returns a new List which excludes this `index` and with a size 1 less
 * than this List. Values at indices above `index` are shifted down by 1 to
 * fill the position.
 * 
 * This is synonymous with `list.splice(index, 1)`.
 * 
 * `index` may be a negative number, which indexes back from the end of the
 * List. `v.delete(-1)` deletes the last item in the List.
 * 
 * Note: `delete` cannot be safely used in IE8
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 0, 1, 2, 3, 4 ]).delete(0);
 * // List [ 1, 2, 3, 4 ]
 * ```
 * 
 * Since `delete()` re-indexes values, it produces a complete copy, which
 * has `O(N)` complexity.
 * 
 * Note: `delete` *cannot* be used in `withMutations`.
 * 
 * \@alias remove
 * @public
 * @param {number} index
 * @return {?}
 */
immutable_.Immutable.List.prototype.delete = function(index) {};

/**
 * @public
 * @param {number} index
 * @return {?}
 */
immutable_.Immutable.List.prototype.remove = function(index) {};

/**
 * Returns a new List with `value` at `index` with a size 1 more than this
 * List. Values at indices above `index` are shifted over by 1.
 * 
 * This is synonymous with `list.splice(index, 0, value)`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 0, 1, 2, 3, 4 ]).insert(6, 5)
 * // List [ 0, 1, 2, 3, 4, 5 ]
 * ```
 * 
 * Since `insert()` re-indexes values, it produces a complete copy, which
 * has `O(N)` complexity.
 * 
 * Note: `insert` *cannot* be used in `withMutations`.
 * @public
 * @param {number} index
 * @param {T} value
 * @return {?}
 */
immutable_.Immutable.List.prototype.insert = function(index, value) {};

/**
 * Returns a new List with 0 size and no values in constant time.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 1, 2, 3, 4 ]).clear()
 * // List []
 * ```
 * 
 * Note: `clear` can be used in `withMutations`.
 * @public
 * @return {?}
 */
immutable_.Immutable.List.prototype.clear = function() {};

/**
 * Returns a new List with the provided `values` appended, starting at this
 * List's `size`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 1, 2, 3, 4 ]).push(5)
 * // List [ 1, 2, 3, 4, 5 ]
 * ```
 * 
 * Note: `push` can be used in `withMutations`.
 * @public
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.List.prototype.push = function(values) {};

/**
 * Returns a new List with a size ones less than this List, excluding
 * the last index in this List.
 * 
 * Note: this differs from `Array#pop` because it returns a new
 * List rather than the removed value. Use `last()` to get the last value
 * in this List.
 * 
 * ```js
 * List([ 1, 2, 3, 4 ]).pop()
 * // List[ 1, 2, 3 ]
 * ```
 * 
 * Note: `pop` can be used in `withMutations`.
 * @public
 * @return {?}
 */
immutable_.Immutable.List.prototype.pop = function() {};

/**
 * Returns a new List with the provided `values` prepended, shifting other
 * values ahead to higher indices.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 2, 3, 4]).unshift(1);
 * // List [ 1, 2, 3, 4 ]
 * ```
 * 
 * Note: `unshift` can be used in `withMutations`.
 * @public
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.List.prototype.unshift = function(values) {};

/**
 * Returns a new List with a size ones less than this List, excluding
 * the first index in this List, shifting all other values to a lower index.
 * 
 * Note: this differs from `Array#shift` because it returns a new
 * List rather than the removed value. Use `first()` to get the first
 * value in this List.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 0, 1, 2, 3, 4 ]).shift();
 * // List [ 1, 2, 3, 4 ]
 * ```
 * 
 * Note: `shift` can be used in `withMutations`.
 * @public
 * @return {?}
 */
immutable_.Immutable.List.prototype.shift = function() {};

/**
 * Returns a new List with an updated value at `index` with the return
 * value of calling `updater` with the existing value, or `notSetValue` if
 * `index` was not set. If called with a single argument, `updater` is
 * called with the List itself.
 * 
 * `index` may be a negative number, which indexes back from the end of the
 * List. `v.update(-1)` updates the last item in the List.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * const list = List([ 'a', 'b', 'c' ])
 * const result = list.update(2, val => val.toUpperCase())
 * // List [ "a", "b", "C" ]
 * ```
 * 
 * This can be very useful as a way to "chain" a normal function into a
 * sequence of methods. RxJS calls this "let" and lodash calls it "thru".
 * 
 * For example, to sum a List after mapping and filtering:
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * function sum(collection) {
 *   return collection.reduce((sum, x) => sum + x, 0)
 * }
 * 
 * List([ 1, 2, 3 ])
 *   .map(x => x + 1)
 *   .filter(x => x % 2 === 0)
 *   .update(sum)
 * // 6
 * ```
 * 
 * Note: `update(index)` can be used in `withMutations`.
 * 
 * @see `Map#update`
 * @public
 * @template THIS,R
 * @this {THIS}
 * @param {number|function(!immutable.Immutable.List): R} index_or_updater
 * @param {T|function((undefined|T)): T=} notSetValue_or_updater
 * @param {function(T): T=} updater
 * @return {THIS|R}
 */
immutable_.Immutable.List.prototype.update = function(index_or_updater, notSetValue_or_updater, updater) {};

/**
 * Returns a new List with size `size`. If `size` is less than this
 * List's size, the new List will exclude values at the higher indices.
 * If `size` is greater than this List's size, the new List will have
 * undefined values for the newly available indices.
 * 
 * When building a new List and the final size is known up front, `setSize`
 * used in conjunction with `withMutations` may result in the more
 * performant construction.
 * @public
 * @param {number} size
 * @return {?}
 */
immutable_.Immutable.List.prototype.setSize = function(size) {};

/**
 * Returns a new List having set `value` at this `keyPath`. If any keys in
 * `keyPath` do not exist, a new immutable Map will be created at that key.
 * 
 * Index numbers are used as keys to determine the path to follow in
 * the List.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * const list = List([ 0, 1, 2, List([ 3, 4 ])])
 * list.setIn([3, 0], 999);
 * // List [ 0, 1, 2, List [ 999, 4 ] ]
 * ```
 * 
 * Plain JavaScript Object or Arrays may be nested within an Immutable.js
 * Collection, and setIn() can update those values as well, treating them
 * immutably by creating new copies of those values with the changes applied.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * const list = List([ 0, 1, 2, { plain: 'object' }])
 * list.setIn([3, 'plain'], 'value');
 * // List([ 0, 1, 2, { plain: 'value' }])
 * ```
 * 
 * Note: `setIn` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {*} value
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.setIn = function(keyPath, value) {};

/**
 * Returns a new List having removed the value at this `keyPath`. If any
 * keys in `keyPath` do not exist, no change will occur.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * const list = List([ 0, 1, 2, List([ 3, 4 ])])
 * list.deleteIn([3, 0]);
 * // List [ 0, 1, 2, List [ 4 ] ]
 * ```
 * 
 * Plain JavaScript Object or Arrays may be nested within an Immutable.js
 * Collection, and removeIn() can update those values as well, treating them
 * immutably by creating new copies of those values with the changes applied.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * const list = List([ 0, 1, 2, { plain: 'object' }])
 * list.removeIn([3, 'plain']);
 * // List([ 0, 1, 2, {}])
 * ```
 * 
 * Note: `deleteIn` *cannot* be safely used in `withMutations`.
 * 
 * \@alias removeIn
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.deleteIn = function(keyPath) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.removeIn = function(keyPath) {};

/**
 * Note: `updateIn` can be used in `withMutations`.
 * 
 * @see `Map#updateIn`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {*|function(*): *} notSetValue_or_updater
 * @param {function(*): *=} updater
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.updateIn = function(keyPath, notSetValue_or_updater, updater) {};

/**
 * Note: `mergeIn` can be used in `withMutations`.
 * 
 * @see `Map#mergeIn`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.mergeIn = function(keyPath, collections) {};

/**
 * Note: `mergeDeepIn` can be used in `withMutations`.
 * 
 * @see `Map#mergeDeepIn`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.mergeDeepIn = function(keyPath, collections) {};

/**
 * Note: Not all methods can be safely used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * allows being used in `withMutations`.
 * 
 * @see `Map#withMutations`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(!immutable.Immutable.List): *} mutator
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.withMutations = function(mutator) {};

/**
 * An alternative API for withMutations()
 * 
 * Note: Not all methods can be safely used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * allows being used in `withMutations`.
 * 
 * @see `Map#asMutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.asMutable = function() {};

/**
 * @see `Map#wasAltered`
 * @public
 * @return {boolean}
 */
immutable_.Immutable.List.prototype.wasAltered = function() {};

/**
 * @see `Map#asImmutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.List.prototype.asImmutable = function() {};

/**
 * Returns a new List with other values or collections concatenated to this one.
 * 
 * Note: `concat` can be used in `withMutations`.
 * 
 * \@alias merge
 * @public
 * @template C
 * @param {...(C|!Iterable<C>)} valuesOrCollections
 * @return {?}
 */
immutable_.Immutable.List.prototype.concat = function(valuesOrCollections) {};

/**
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.List.prototype.merge = function(collections) {};

/**
 * Returns a new List with values passed through a
 * `mapper` function.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * List([ 1, 2 ]).map(x => 10 * x)
 * // List [ 10, 20 ]
 * ```
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.List): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.List.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the List, returning a new List.
 * 
 * Similar to `list.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.List): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.List.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new List with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, number, !immutable.Immutable.List): boolean|function(T, number, !immutable.Immutable.List): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.List.prototype.filter = function(predicate, context) {};

/**
 * Returns a List "zipped" with the provided collection.
 * 
 * Like `zipWith`, but using the default `zipper`: creating an `Array`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 4, 5, 6 ]);
 * const c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.List.prototype.zip = function(other_or_collections) {};

/**
 * Returns a List "zipped" with the provided collections.
 * 
 * Unlike `zip`, `zipAll` continues zipping until the longest collection is
 * exhausted. Missing values from shorter collections are filled with `undefined`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * const a = List([ 1, 2 ]);
 * const b = List([ 3, 4, 5 ]);
 * const c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]
 * ```
 * 
 * Note: Since zipAll will return a collection as large as the largest
 * input, some results may contain undefined values. TypeScript cannot
 * account for these without cases (as of v2.5).
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.List.prototype.zipAll = function(other_or_collections) {};

/**
 * Returns a List "zipped" with the provided collections by using a
 * custom `zipper` function.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable');" }
 * -->
 * ```js
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 4, 5, 6 ]);
 * const c = a.zipWith((a, b) => a + b, b);
 * // List [ 5, 7, 9 ]
 * ```
 * @public
 * @template U, Z, V
 * @param {function(T, U): Z|function(T, U, V): Z|function(...*): Z} zipper
 * @param {...?} otherCollection_or_collections
 * @return {?}
 */
immutable_.Immutable.List.prototype.zipWith = function(zipper, otherCollection_or_collections) {};

/**
 * True if the provided value is a Map
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map.isMap({}) // false
 * Map.isMap(Map()) // true
 * ```
 * @param {*} maybeMap
 * @return {boolean}
 */
immutable_.Immutable.Map.isMap = function(maybeMap) {};

/**
 * Creates a new Map from alternating keys and values
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map.of(
 *   'key', 'value',
 *   'numerical value', 3,
 *    0, 'numerical key'
 * )
 * // Map { 0: "numerical key", "key": "value", "numerical value": 3 }
 * ```
 * 
 * @deprecated Use Map([ [ 'k', 'v' ] ]) or Map({ k: 'v' })
 * @param {...*} keyValues
 * @return {?}
 */
immutable_.Immutable.Map.of = function(keyValues) {};

/**
 * Creates a new Immutable Map.
 * 
 * Created with the same key value pairs as the provided Collection.Keyed or
 * JavaScript Object or expects a Collection of [K, V] tuple entries.
 * 
 * Note: `Map` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ key: "value" })
 * Map([ [ "key", "value" ] ])
 * ```
 * 
 * Keep in mind, when using JS objects to construct Immutable Maps, that
 * JavaScript Object properties are always strings, even if written in a
 * quote-less shorthand, while Immutable Maps accept keys of any type.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * let obj = { 1: "one" }
 * Object.keys(obj) // [ "1" ]
 * assert.equal(obj["1"], obj[1]) // "one" === "one"
 * 
 * let map = Map(obj)
 * assert.notEqual(map.get("1"), map.get(1)) // "one" !== undefined
 * ```
 * 
 * Property access for JavaScript Objects first converts the key to a string,
 * but since Immutable Map keys can be of any type the argument to `get()` is
 * not altered.
 * @template K, V
 * @param {(undefined|!Iterable<!Array<?>>)|!Object<string,V>|?=} collection_or_obj
 * @return {?}
 */
immutable_.Immutable.Map = function(collection_or_obj) {};
/** @type {number} */
immutable_.Immutable.Map.prototype.size;

/**
 * Returns a new Map also containing the new key, value pair. If an equivalent
 * key already exists in this Map, it will be replaced.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const originalMap = Map()
 * const newerMap = originalMap.set('key', 'value')
 * const newestMap = newerMap.set('key', 'newer value')
 * 
 * originalMap
 * // Map {}
 * newerMap
 * // Map { "key": "value" }
 * newestMap
 * // Map { "key": "newer value" }
 * ```
 * 
 * Note: `set` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {K} key
 * @param {V} value
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.set = function(key, value) {};

/**
 * Returns a new Map which excludes this `key`.
 * 
 * Note: `delete` cannot be safely used in IE8, but is provided to mirror
 * the ES6 collection API.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const originalMap = Map({
 *   key: 'value',
 *   otherKey: 'other value'
 * })
 * // Map { "key": "value", "otherKey": "other value" }
 * originalMap.delete('otherKey')
 * // Map { "key": "value" }
 * ```
 * 
 * Note: `delete` can be used in `withMutations`.
 * 
 * \@alias remove
 * @public
 * @template THIS
 * @this {THIS}
 * @param {K} key
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.delete = function(key) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {K} key
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.remove = function(key) {};

/**
 * Returns a new Map which excludes the provided `keys`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const names = Map({ a: "Aaron", b: "Barry", c: "Connor" })
 * names.deleteAll([ 'a', 'c' ])
 * // Map { "b": "Barry" }
 * ```
 * 
 * Note: `deleteAll` can be used in `withMutations`.
 * 
 * \@alias removeAll
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<K>} keys
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.deleteAll = function(keys) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<K>} keys
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.removeAll = function(keys) {};

/**
 * Returns a new Map containing no keys or values.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ key: 'value' }).clear()
 * // Map {}
 * ```
 * 
 * Note: `clear` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.clear = function() {};

/**
 * Returns a new Map having updated the value at this `key` with the return
 * value of calling `updater` with the existing value.
 * 
 * Similar to: `map.set(key, updater(map.get(key)))`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const aMap = Map({ key: 'value' })
 * const newMap = aMap.update('key', value => value + value)
 * // Map { "key": "valuevalue" }
 * ```
 * 
 * This is most commonly used to call methods on collections within a
 * structure of data. For example, in order to `.push()` onto a nested `List`,
 * `update` and `push` can be used together:
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map, List } = require('immutable');" }
 * -->
 * ```js
 * const aMap = Map({ nestedList: List([ 1, 2, 3 ]) })
 * const newMap = aMap.update('nestedList', list => list.push(4))
 * // Map { "nestedList": List [ 1, 2, 3, 4 ] }
 * ```
 * 
 * When a `notSetValue` is provided, it is provided to the `updater`
 * function when the value at the key does not exist in the Map.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * const aMap = Map({ key: 'value' })
 * const newMap = aMap.update('noKey', 'no value', value => value + value)
 * // Map { "key": "value", "noKey": "no valueno value" }
 * ```
 * 
 * However, if the `updater` function returns the same value it was called
 * with, then no change will occur. This is still true if `notSetValue`
 * is provided.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * const aMap = Map({ apples: 10 })
 * const newMap = aMap.update('oranges', 0, val => val)
 * // Map { "apples": 10 }
 * assert.strictEqual(newMap, map);
 * ```
 * 
 * For code using ES2015 or later, using `notSetValue` is discourged in
 * favor of function parameter default values. This helps to avoid any
 * potential confusion with identify functions as described above.
 * 
 * The previous example behaves differently when written with default values:
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * const aMap = Map({ apples: 10 })
 * const newMap = aMap.update('oranges', (val = 0) => val)
 * // Map { "apples": 10, "oranges": 0 }
 * ```
 * 
 * If no key is provided, then the `updater` function return value is
 * returned as well.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * const aMap = Map({ key: 'value' })
 * const result = aMap.update(aMap => aMap.get('key'))
 * // "value"
 * ```
 * 
 * This can be very useful as a way to "chain" a normal function into a
 * sequence of methods. RxJS calls this "let" and lodash calls it "thru".
 * 
 * For example, to sum the values in a Map
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable');" }
 * -->
 * ```js
 * function sum(collection) {
 *   return collection.reduce((sum, x) => sum + x, 0)
 * }
 * 
 * Map({ x: 1, y: 2, z: 3 })
 *   .map(x => x + 1)
 *   .filter(x => x % 2 === 0)
 *   .update(sum)
 * // 6
 * ```
 * 
 * Note: `update(key)` can be used in `withMutations`.
 * @public
 * @template THIS,R
 * @this {THIS}
 * @param {K|function(!immutable.Immutable.Map): R} key_or_updater
 * @param {V|function((undefined|V)): V=} notSetValue_or_updater
 * @param {function(V): V=} updater
 * @return {THIS|R}
 */
immutable_.Immutable.Map.prototype.update = function(key_or_updater, notSetValue_or_updater, updater) {};

/**
 * Returns a new Map resulting from merging the provided Collections
 * (or JS objects) into this Map. In other words, this takes each entry of
 * each collection and sets it on this Map.
 * 
 * Note: Values provided to `merge` are shallowly converted before being
 * merged. No nested values are altered.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const one = Map({ a: 10, b: 20, c: 30 })
 * const two = Map({ b: 40, a: 50, d: 60 })
 * one.merge(two) // Map { "a": 50, "b": 40, "c": 30, "d": 60 }
 * two.merge(one) // Map { "b": 20, "a": 10, "d": 60, "c": 30 }
 * ```
 * 
 * Note: `merge` can be used in `withMutations`.
 * 
 * \@alias concat
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.Map.prototype.merge = function(collections) {};

/**
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.Map.prototype.concat = function(collections) {};

/**
 * Like `merge()`, `mergeWith()` returns a new Map resulting from merging
 * the provided Collections (or JS objects) into this Map, but uses the
 * `merger` function for dealing with conflicts.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const one = Map({ a: 10, b: 20, c: 30 })
 * const two = Map({ b: 40, a: 50, d: 60 })
 * one.mergeWith((oldVal, newVal) => oldVal / newVal, two)
 * // { "a": 0.2, "b": 0.5, "c": 30, "d": 60 }
 * two.mergeWith((oldVal, newVal) => oldVal / newVal, one)
 * // { "b": 2, "a": 5, "d": 60, "c": 30 }
 * ```
 * 
 * Note: `mergeWith` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, V, K): V} merger
 * @param {...(!Iterable<!Array<?>>|!Object<string,V>)} collections
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.mergeWith = function(merger, collections) {};

/**
 * Like `merge()`, but when two compatible collections are encountered with
 * the same key, it merges them as well, recursing deeply through the nested
 * data. Two collections are considered to be compatible (and thus will be
 * merged together) if they both fall into one of three categories: keyed
 * (e.g., `Map`s, `Record`s, and objects), indexed (e.g., `List`s and
 * arrays), or set-like (e.g., `Set`s). If they fall into separate
 * categories, `mergeDeep` will replace the existing collection with the
 * collection being merged in. This behavior can be customized by using
 * `mergeDeepWith()`.
 * 
 * Note: Indexed and set-like collections are merged using
 * `concat()`/`union()` and therefore do not recurse.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
 * const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
 * one.mergeDeep(two)
 * // Map {
 * //   "a": Map { "x": 2, "y": 10 },
 * //   "b": Map { "x": 20, "y": 5 },
 * //   "c": Map { "z": 3 }
 * // }
 * ```
 * 
 * Note: `mergeDeep` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...(!Iterable<!Array<?>>|!Object<string,V>)} collections
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.mergeDeep = function(collections) {};

/**
 * Like `mergeDeep()`, but when two non-collections or incompatible
 * collections are encountered at the same key, it uses the `merger`
 * function to determine the resulting value. Collections are considered
 * incompatible if they fall into separate categories between keyed,
 * indexed, and set-like.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
 * const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
 * one.mergeDeepWith((oldVal, newVal) => oldVal / newVal, two)
 * // Map {
 * //   "a": Map { "x": 5, "y": 10 },
 * //   "b": Map { "x": 20, "y": 10 },
 * //   "c": Map { "z": 3 }
 * // }
 * ```
 * 
 * Note: `mergeDeepWith` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(*, *, *): *} merger
 * @param {...(!Iterable<!Array<?>>|!Object<string,V>)} collections
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.mergeDeepWith = function(merger, collections) {};

/**
 * Returns a new Map having set `value` at this `keyPath`. If any keys in
 * `keyPath` do not exist, a new immutable Map will be created at that key.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const originalMap = Map({
 *   subObject: Map({
 *     subKey: 'subvalue',
 *     subSubObject: Map({
 *       subSubKey: 'subSubValue'
 *     })
 *   })
 * })
 * 
 * const newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!')
 * // Map {
 * //   "subObject": Map {
 * //     "subKey": "ha ha!",
 * //     "subSubObject": Map { "subSubKey": "subSubValue" }
 * //   }
 * // }
 * 
 * const newerMap = originalMap.setIn(
 *   ['subObject', 'subSubObject', 'subSubKey'],
 *   'ha ha ha!'
 * )
 * // Map {
 * //   "subObject": Map {
 * //     "subKey": "subvalue",
 * //     "subSubObject": Map { "subSubKey": "ha ha ha!" }
 * //   }
 * // }
 * ```
 * 
 * Plain JavaScript Object or Arrays may be nested within an Immutable.js
 * Collection, and setIn() can update those values as well, treating them
 * immutably by creating new copies of those values with the changes applied.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const originalMap = Map({
 *   subObject: {
 *     subKey: 'subvalue',
 *     subSubObject: {
 *       subSubKey: 'subSubValue'
 *     }
 *   }
 * })
 * 
 * originalMap.setIn(['subObject', 'subKey'], 'ha ha!')
 * // Map {
 * //   "subObject": {
 * //     subKey: "ha ha!",
 * //     subSubObject: { subSubKey: "subSubValue" }
 * //   }
 * // }
 * ```
 * 
 * If any key in the path exists but cannot be updated (such as a primitive
 * like number or a custom Object like Date), an error will be thrown.
 * 
 * Note: `setIn` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {*} value
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.setIn = function(keyPath, value) {};

/**
 * Returns a new Map having removed the value at this `keyPath`. If any keys
 * in `keyPath` do not exist, no change will occur.
 * 
 * Note: `deleteIn` can be used in `withMutations`.
 * 
 * \@alias removeIn
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.deleteIn = function(keyPath) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.removeIn = function(keyPath) {};

/**
 * Returns a new Map having applied the `updater` to the entry found at the
 * keyPath.
 * 
 * This is most commonly used to call methods on collections nested within a
 * structure of data. For example, in order to `.push()` onto a nested `List`,
 * `updateIn` and `push` can be used together:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map, List } = require('immutable')
 * const map = Map({ inMap: Map({ inList: List([ 1, 2, 3 ]) }) })
 * const newMap = map.updateIn(['inMap', 'inList'], list => list.push(4))
 * // Map { "inMap": Map { "inList": List [ 1, 2, 3, 4 ] } }
 * ```
 * 
 * If any keys in `keyPath` do not exist, new Immutable `Map`s will
 * be created at those keys. If the `keyPath` does not already contain a
 * value, the `updater` function will be called with `notSetValue`, if
 * provided, otherwise `undefined`.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable')" }
 * -->
 * ```js
 * const map = Map({ a: Map({ b: Map({ c: 10 }) }) })
 * const newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)
 * // Map { "a": Map { "b": Map { "c": 20 } } }
 * ```
 * 
 * If the `updater` function returns the same value it was called with, then
 * no change will occur. This is still true if `notSetValue` is provided.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable')" }
 * -->
 * ```js
 * const map = Map({ a: Map({ b: Map({ c: 10 }) }) })
 * const newMap = map.updateIn(['a', 'b', 'x'], 100, val => val)
 * // Map { "a": Map { "b": Map { "c": 10 } } }
 * assert.strictEqual(newMap, aMap)
 * ```
 * 
 * For code using ES2015 or later, using `notSetValue` is discourged in
 * favor of function parameter default values. This helps to avoid any
 * potential confusion with identify functions as described above.
 * 
 * The previous example behaves differently when written with default values:
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable')" }
 * -->
 * ```js
 * const map = Map({ a: Map({ b: Map({ c: 10 }) }) })
 * const newMap = map.updateIn(['a', 'b', 'x'], (val = 100) => val)
 * // Map { "a": Map { "b": Map { "c": 10, "x": 100 } } }
 * ```
 * 
 * Plain JavaScript Object or Arrays may be nested within an Immutable.js
 * Collection, and updateIn() can update those values as well, treating them
 * immutably by creating new copies of those values with the changes applied.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Map } = require('immutable')" }
 * -->
 * ```js
 * const map = Map({ a: { b: { c: 10 } } })
 * const newMap = map.updateIn(['a', 'b', 'c'], val => val * 2)
 * // Map { "a": { b: { c: 20 } } }
 * ```
 * 
 * If any key in the path exists but cannot be updated (such as a primitive
 * like number or a custom Object like Date), an error will be thrown.
 * 
 * Note: `updateIn` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {*|function(*): *} notSetValue_or_updater
 * @param {function(*): *=} updater
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.updateIn = function(keyPath, notSetValue_or_updater, updater) {};

/**
 * A combination of `updateIn` and `merge`, returning a new Map, but
 * performing the merge at a point arrived at by following the keyPath.
 * In other words, these two lines are equivalent:
 * 
 * ```js
 * map.updateIn(['a', 'b', 'c'], abc => abc.merge(y))
 * map.mergeIn(['a', 'b', 'c'], y)
 * ```
 * 
 * Note: `mergeIn` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.mergeIn = function(keyPath, collections) {};

/**
 * A combination of `updateIn` and `mergeDeep`, returning a new Map, but
 * performing the deep merge at a point arrived at by following the keyPath.
 * In other words, these two lines are equivalent:
 * 
 * ```js
 * map.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y))
 * map.mergeDeepIn(['a', 'b', 'c'], y)
 * ```
 * 
 * Note: `mergeDeepIn` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.mergeDeepIn = function(keyPath, collections) {};

/**
 * Every time you call one of the above functions, a new immutable Map is
 * created. If a pure function calls a number of these to produce a final
 * return value, then a penalty on performance and memory has been paid by
 * creating all of the intermediate immutable Maps.
 * 
 * If you need to apply a series of mutations to produce a new immutable
 * Map, `withMutations()` creates a temporary mutable copy of the Map which
 * can apply mutations in a highly performant manner. In fact, this is
 * exactly how complex mutations like `merge` are done.
 * 
 * As an example, this results in the creation of 2, not 4, new Maps:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const map1 = Map()
 * const map2 = map1.withMutations(map => {
 *   map.set('a', 1).set('b', 2).set('c', 3)
 * })
 * assert.equal(map1.size, 0)
 * assert.equal(map2.size, 3)
 * ```
 * 
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Read the documentation for each method to see if it
 * is safe to use in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(!immutable.Immutable.Map): *} mutator
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.withMutations = function(mutator) {};

/**
 * Another way to avoid creation of intermediate Immutable maps is to create
 * a mutable copy of this collection. Mutable copies *always* return `this`,
 * and thus shouldn't be used for equality. Your function should never return
 * a mutable copy of a collection, only use it internally to create a new
 * collection.
 * 
 * If possible, use `withMutations` to work with temporary mutable copies as
 * it provides an easier to use API and considers many common optimizations.
 * 
 * Note: if the collection is already mutable, `asMutable` returns itself.
 * 
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Read the documentation for each method to see if it
 * is safe to use in `withMutations`.
 * 
 * @see `Map#asImmutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.asMutable = function() {};

/**
 * Returns true if this is a mutable copy (see `asMutable()`) and mutative
 * alterations have been applied.
 * 
 * @see `Map#asMutable`
 * @public
 * @return {boolean}
 */
immutable_.Immutable.Map.prototype.wasAltered = function() {};

/**
 * The yin to `asMutable`'s yang. Because it applies to mutable collections,
 * this operation is *mutable* and may return itself (though may not
 * return itself, i.e. if the result is an empty collection). Once
 * performed, the original mutable copy must no longer be mutated since it
 * may be the immutable result.
 * 
 * If possible, use `withMutations` to work with temporary mutable copies as
 * it provides an easier to use API and considers many common optimizations.
 * 
 * @see `Map#asMutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Map.prototype.asImmutable = function() {};

/**
 * Returns a new Map with values passed through a
 * `mapper` function.
 * 
 *     Map({ a: 1, b: 2 }).map(x => 10 * x)
 *     // Map { a: 10, b: 20 }
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.Map): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Map.prototype.map = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapKeys
 * @public
 * @template M
 * @param {function(K, V, !immutable.Immutable.Map): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Map.prototype.mapKeys = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapEntries
 * @public
 * @template KM, VM
 * @param {function(!Array<?>, number, !immutable.Immutable.Map): (undefined|!Array<?>)} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Map.prototype.mapEntries = function(mapper, context) {};

/**
 * Flat-maps the Map, returning a new Map.
 * 
 * Similar to `data.map(...).flatten(true)`.
 * @public
 * @template KM, VM
 * @param {function(V, K, !immutable.Immutable.Map): !Iterable<!Array<?>>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Map.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Map with only the entries for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Map): boolean|function(V, K, !immutable.Immutable.Map): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Map.prototype.filter = function(predicate, context) {};

/**
 * @see Collection.Keyed.flip
 * @public
 * @return {?}
 */
immutable_.Immutable.Map.prototype.flip = function() {};

/**
 * True if the provided value is an OrderedMap.
 * @param {*} maybeOrderedMap
 * @return {boolean}
 */
immutable_.Immutable.OrderedMap.isOrderedMap = function(maybeOrderedMap) {};

/**
 * Creates a new Immutable OrderedMap.
 * 
 * Created with the same key value pairs as the provided Collection.Keyed or
 * JavaScript Object or expects a Collection of [K, V] tuple entries.
 * 
 * The iteration order of key-value pairs provided to this constructor will
 * be preserved in the OrderedMap.
 * 
 *     let newOrderedMap = OrderedMap({key: "value"})
 *     let newOrderedMap = OrderedMap([["key", "value"]])
 * 
 * Note: `OrderedMap` is a factory function and not a class, and does not use
 * the `new` keyword during construction.
 * @template K, V
 * @param {(undefined|!Iterable<!Array<?>>)|!Object<string,V>=} collection_or_obj
 * @return {?}
 */
immutable_.Immutable.OrderedMap = function(collection_or_obj) {};
/** @type {number} */
immutable_.Immutable.OrderedMap.prototype.size;

/**
 * Returns a new OrderedMap also containing the new key, value pair. If an
 * equivalent key already exists in this OrderedMap, it will be replaced
 * while maintaining the existing order.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { OrderedMap } = require('immutable')
 * const originalMap = OrderedMap({a:1, b:1, c:1})
 * const updatedMap = originalMap.set('b', 2)
 * 
 * originalMap
 * // OrderedMap {a: 1, b: 1, c: 1}
 * updatedMap
 * // OrderedMap {a: 1, b: 2, c: 1}
 * ```
 * 
 * Note: `set` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {K} key
 * @param {V} value
 * @return {THIS}
 */
immutable_.Immutable.OrderedMap.prototype.set = function(key, value) {};

/**
 * Returns a new OrderedMap resulting from merging the provided Collections
 * (or JS objects) into this OrderedMap. In other words, this takes each
 * entry of each collection and sets it on this OrderedMap.
 * 
 * Note: Values provided to `merge` are shallowly converted before being
 * merged. No nested values are altered.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { OrderedMap } = require('immutable')
 * const one = OrderedMap({ a: 10, b: 20, c: 30 })
 * const two = OrderedMap({ b: 40, a: 50, d: 60 })
 * one.merge(two) // OrderedMap { "a": 50, "b": 40, "c": 30, "d": 60 }
 * two.merge(one) // OrderedMap { "b": 20, "a": 10, "d": 60, "c": 30 }
 * ```
 * 
 * Note: `merge` can be used in `withMutations`.
 * 
 * \@alias concat
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.merge = function(collections) {};

/**
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.concat = function(collections) {};

/**
 * Returns a new OrderedMap with values passed through a
 * `mapper` function.
 * 
 *     OrderedMap({ a: 1, b: 2 }).map(x => 10 * x)
 *     // OrderedMap { "a": 10, "b": 20 }
 * 
 * Note: `map()` always returns a new instance, even if it produced the same
 * value at every step.
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.OrderedMap): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.map = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapKeys
 * @public
 * @template M
 * @param {function(K, V, !immutable.Immutable.OrderedMap): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.mapKeys = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapEntries
 * @public
 * @template KM, VM
 * @param {function(!Array<?>, number, !immutable.Immutable.OrderedMap): (undefined|!Array<?>)} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.mapEntries = function(mapper, context) {};

/**
 * Flat-maps the OrderedMap, returning a new OrderedMap.
 * 
 * Similar to `data.map(...).flatten(true)`.
 * @public
 * @template KM, VM
 * @param {function(V, K, !immutable.Immutable.OrderedMap): !Iterable<!Array<?>>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new OrderedMap with only the entries for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.OrderedMap): boolean|function(V, K, !immutable.Immutable.OrderedMap): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.OrderedMap.prototype.filter = function(predicate, context) {};

/**
 * @see Collection.Keyed.flip
 * @public
 * @return {?}
 */
immutable_.Immutable.OrderedMap.prototype.flip = function() {};

/**
 * True if the provided value is a Set
 * @param {*} maybeSet
 * @return {boolean}
 */
immutable_.Immutable.Set.isSet = function(maybeSet) {};

/**
 * Creates a new Set containing `values`.
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Set.of = function(values) {};

/**
 * `Set.fromKeys()` creates a new immutable Set containing the keys from
 * this Collection or JavaScript Object.
 * @template T
 * @param {?|!Object<string,*>} iter_or_obj
 * @return {?}
 */
immutable_.Immutable.Set.fromKeys = function(iter_or_obj) {};

/**
 * `Set.intersect()` creates a new immutable Set that is the intersection of
 * a collection of other sets.
 * 
 * ```js
 * const { Set } = require('immutable')
 * const intersected = Set.intersect([
 *   Set([ 'a', 'b', 'c' ])
 *   Set([ 'c', 'a', 't' ])
 * ])
 * // Set [ "a", "c" ]
 * ```
 * @template T
 * @param {!Iterable<!Iterable<T>>} sets
 * @return {?}
 */
immutable_.Immutable.Set.intersect = function(sets) {};

/**
 * `Set.union()` creates a new immutable Set that is the union of a
 * collection of other sets.
 * 
 * ```js
 * const { Set } = require('immutable')
 * const unioned = Set.union([
 *   Set([ 'a', 'b', 'c' ])
 *   Set([ 'c', 'a', 't' ])
 * ])
 * // Set [ "a", "b", "c", "t" ]
 * ```
 * @template T
 * @param {!Iterable<!Iterable<T>>} sets
 * @return {?}
 */
immutable_.Immutable.Set.union = function(sets) {};

/**
 * Create a new immutable Set containing the values of the provided
 * collection-like.
 * 
 * Note: `Set` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Set = function(collection) {};
/** @type {number} */
immutable_.Immutable.Set.prototype.size;

/**
 * Returns a new Set which also includes this value.
 * 
 * Note: `add` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {T} value
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.add = function(value) {};

/**
 * Returns a new Set which excludes this value.
 * 
 * Note: `delete` can be used in `withMutations`.
 * 
 * Note: `delete` **cannot** be safely used in IE8, use `remove` if
 * supporting old browsers.
 * 
 * \@alias remove
 * @public
 * @template THIS
 * @this {THIS}
 * @param {T} value
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.delete = function(value) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {T} value
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.remove = function(value) {};

/**
 * Returns a new Set containing no values.
 * 
 * Note: `clear` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.clear = function() {};

/**
 * Returns a Set including any value from `collections` that does not already
 * exist in this Set.
 * 
 * Note: `union` can be used in `withMutations`.
 * \@alias merge / concat
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.Set.prototype.union = function(collections) {};

/**
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.Set.prototype.merge = function(collections) {};

/**
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.Set.prototype.concat = function(collections) {};

/**
 * Returns a Set which has removed any values not also contained
 * within `collections`.
 * 
 * Note: `intersect` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...!Iterable<T>} collections
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.intersect = function(collections) {};

/**
 * Returns a Set excluding any values contained within `collections`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { OrderedSet } = require('immutable')
 * OrderedSet([ 1, 2, 3 ]).subtract([1, 3])
 * // OrderedSet [2]
 * ```
 * 
 * Note: `subtract` can be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...!Iterable<T>} collections
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.subtract = function(collections) {};

/**
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * mentions being safe to use in `withMutations`.
 * 
 * @see `Map#withMutations`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(!immutable.Immutable.Set): *} mutator
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.withMutations = function(mutator) {};

/**
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * mentions being safe to use in `withMutations`.
 * 
 * @see `Map#asMutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.asMutable = function() {};

/**
 * @see `Map#wasAltered`
 * @public
 * @return {boolean}
 */
immutable_.Immutable.Set.prototype.wasAltered = function() {};

/**
 * @see `Map#asImmutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Set.prototype.asImmutable = function() {};

/**
 * Returns a new Set with values passed through a
 * `mapper` function.
 * 
 *     Set([1,2]).map(x => 10 * x)
 *     // Set [10,20]
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Set): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Set.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Set, returning a new Set.
 * 
 * Similar to `set.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Set): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Set.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Set with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, T, !immutable.Immutable.Set): boolean|function(T, T, !immutable.Immutable.Set): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Set.prototype.filter = function(predicate, context) {};

/**
 * True if the provided value is an OrderedSet.
 * @param {*} maybeOrderedSet
 * @return {boolean}
 */
immutable_.Immutable.OrderedSet.isOrderedSet = function(maybeOrderedSet) {};

/**
 * Creates a new OrderedSet containing `values`.
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.OrderedSet.of = function(values) {};

/**
 * `OrderedSet.fromKeys()` creates a new immutable OrderedSet containing
 * the keys from this Collection or JavaScript Object.
 * @template T
 * @param {?|!Object<string,*>} iter_or_obj
 * @return {?}
 */
immutable_.Immutable.OrderedSet.fromKeys = function(iter_or_obj) {};

/**
 * Create a new immutable OrderedSet containing the values of the provided
 * collection-like.
 * 
 * Note: `OrderedSet` is a factory function and not a class, and does not use
 * the `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.OrderedSet = function(collection) {};
/** @type {number} */
immutable_.Immutable.OrderedSet.prototype.size;

/**
 * Returns an OrderedSet including any value from `collections` that does
 * not already exist in this OrderedSet.
 * 
 * Note: `union` can be used in `withMutations`.
 * \@alias merge / concat
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.union = function(collections) {};

/**
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.merge = function(collections) {};

/**
 * @public
 * @template C
 * @param {...!Iterable<C>} collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.concat = function(collections) {};

/**
 * Returns a new Set with values passed through a
 * `mapper` function.
 * 
 *     OrderedSet([ 1, 2 ]).map(x => 10 * x)
 *     // OrderedSet [10, 20]
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.OrderedSet): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the OrderedSet, returning a new OrderedSet.
 * 
 * Similar to `set.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.OrderedSet): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new OrderedSet with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, T, !immutable.Immutable.OrderedSet): boolean|function(T, T, !immutable.Immutable.OrderedSet): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.OrderedSet.prototype.filter = function(predicate, context) {};

/**
 * Returns an OrderedSet of the same type "zipped" with the provided
 * collections.
 * 
 * Like `zipWith`, but using the default `zipper`: creating an `Array`.
 * 
 * ```js
 * const a = OrderedSet([ 1, 2, 3 ])
 * const b = OrderedSet([ 4, 5, 6 ])
 * const c = a.zip(b)
 * // OrderedSet [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_other1_or_collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.zip = function(other_or_other1_or_collections) {};

/**
 * Returns a OrderedSet of the same type "zipped" with the provided
 * collections.
 * 
 * Unlike `zip`, `zipAll` continues zipping until the longest collection is
 * exhausted. Missing values from shorter collections are filled with `undefined`.
 * 
 * ```js
 * const a = OrderedSet([ 1, 2 ]);
 * const b = OrderedSet([ 3, 4, 5 ]);
 * const c = a.zipAll(b); // OrderedSet [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]
 * ```
 * 
 * Note: Since zipAll will return a collection as large as the largest
 * input, some results may contain undefined values. TypeScript cannot
 * account for these without cases (as of v2.5).
 * @public
 * @template U, V
 * @param {...?} other_or_other1_or_collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.zipAll = function(other_or_other1_or_collections) {};

/**
 * Returns an OrderedSet of the same type "zipped" with the provided
 * collections by using a custom `zipper` function.
 * 
 * @see Seq.Indexed.zipWith
 * @public
 * @template U, Z, V
 * @param {function(T, U): Z|function(T, U, V): Z|function(...*): Z} zipper
 * @param {...?} otherCollection_or_collections
 * @return {?}
 */
immutable_.Immutable.OrderedSet.prototype.zipWith = function(zipper, otherCollection_or_collections) {};

/**
 * True if the provided value is a Stack
 * @param {*} maybeStack
 * @return {boolean}
 */
immutable_.Immutable.Stack.isStack = function(maybeStack) {};

/**
 * Creates a new Stack containing `values`.
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Stack.of = function(values) {};

/**
 * Create a new immutable Stack containing the values of the provided
 * collection-like.
 * 
 * The iteration order of the provided collection is preserved in the
 * resulting `Stack`.
 * 
 * Note: `Stack` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Stack = function(collection) {};
/** @type {number} */
immutable_.Immutable.Stack.prototype.size;

/**
 * Alias for `Stack.first()`.
 * @public
 * @return {(undefined|T)}
 */
immutable_.Immutable.Stack.prototype.peek = function() {};

/**
 * Returns a new Stack with 0 size and no values.
 * 
 * Note: `clear` can be used in `withMutations`.
 * @public
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.clear = function() {};

/**
 * Returns a new Stack with the provided `values` prepended, shifting other
 * values ahead to higher indices.
 * 
 * This is very efficient for Stack.
 * 
 * Note: `unshift` can be used in `withMutations`.
 * @public
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.unshift = function(values) {};

/**
 * Like `Stack#unshift`, but accepts a collection rather than varargs.
 * 
 * Note: `unshiftAll` can be used in `withMutations`.
 * @public
 * @param {!Iterable<T>} iter
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.unshiftAll = function(iter) {};

/**
 * Returns a new Stack with a size ones less than this Stack, excluding
 * the first item in this Stack, shifting all other values to a lower index.
 * 
 * Note: this differs from `Array#shift` because it returns a new
 * Stack rather than the removed value. Use `first()` or `peek()` to get the
 * first value in this Stack.
 * 
 * Note: `shift` can be used in `withMutations`.
 * @public
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.shift = function() {};

/**
 * Alias for `Stack#unshift` and is not equivalent to `List#push`.
 * @public
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.push = function(values) {};

/**
 * Alias for `Stack#unshiftAll`.
 * @public
 * @param {!Iterable<T>} iter
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.pushAll = function(iter) {};

/**
 * Alias for `Stack#shift` and is not equivalent to `List#pop`.
 * @public
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.pop = function() {};

/**
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * mentions being safe to use in `withMutations`.
 * 
 * @see `Map#withMutations`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(!immutable.Immutable.Stack): *} mutator
 * @return {THIS}
 */
immutable_.Immutable.Stack.prototype.withMutations = function(mutator) {};

/**
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Check the documentation for each method to see if it
 * mentions being safe to use in `withMutations`.
 * 
 * @see `Map#asMutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Stack.prototype.asMutable = function() {};

/**
 * @see `Map#wasAltered`
 * @public
 * @return {boolean}
 */
immutable_.Immutable.Stack.prototype.wasAltered = function() {};

/**
 * @see `Map#asImmutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Stack.prototype.asImmutable = function() {};

/**
 * Returns a new Stack with other collections concatenated to this one.
 * @public
 * @template C
 * @param {...(C|!Iterable<C>)} valuesOrCollections
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.concat = function(valuesOrCollections) {};

/**
 * Returns a new Stack with values passed through a
 * `mapper` function.
 * 
 *     Stack([ 1, 2 ]).map(x => 10 * x)
 *     // Stack [ 10, 20 ]
 * 
 * Note: `map()` always returns a new instance, even if it produced the same
 * value at every step.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Stack): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Stack, returning a new Stack.
 * 
 * Similar to `stack.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Stack): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Set with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, number, !immutable.Immutable.Stack): boolean|function(T, number, !immutable.Immutable.Stack): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Stack.prototype.filter = function(predicate, context) {};

/**
 * Returns a Stack "zipped" with the provided collections.
 * 
 * Like `zipWith`, but using the default `zipper`: creating an `Array`.
 * 
 * ```js
 * const a = Stack([ 1, 2, 3 ]);
 * const b = Stack([ 4, 5, 6 ]);
 * const c = a.zip(b); // Stack [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.zip = function(other_or_collections) {};

/**
 * Returns a Stack "zipped" with the provided collections.
 * 
 * Unlike `zip`, `zipAll` continues zipping until the longest collection is
 * exhausted. Missing values from shorter collections are filled with `undefined`.
 * 
 * ```js
 * const a = Stack([ 1, 2 ]);
 * const b = Stack([ 3, 4, 5 ]);
 * const c = a.zipAll(b); // Stack [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]
 * ```
 * 
 * Note: Since zipAll will return a collection as large as the largest
 * input, some results may contain undefined values. TypeScript cannot
 * account for these without cases (as of v2.5).
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.zipAll = function(other_or_collections) {};

/**
 * Returns a Stack "zipped" with the provided collections by using a
 * custom `zipper` function.
 * 
 * ```js
 * const a = Stack([ 1, 2, 3 ]);
 * const b = Stack([ 4, 5, 6 ]);
 * const c = a.zipWith((a, b) => a + b, b);
 * // Stack [ 5, 7, 9 ]
 * ```
 * @public
 * @template U, Z, V
 * @param {function(T, U): Z|function(T, U, V): Z|function(...*): Z} zipper
 * @param {...?} otherCollection_or_collections
 * @return {?}
 */
immutable_.Immutable.Stack.prototype.zipWith = function(zipper, otherCollection_or_collections) {};

/**
 * Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`
 * (exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to
 * infinity. When `start` is equal to `end`, returns empty range.
 * 
 * Note: `Range` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * 
 * ```js
 * const { Range } = require('immutable')
 * Range() // [ 0, 1, 2, 3, ... ]
 * Range(10) // [ 10, 11, 12, 13, ... ]
 * Range(10, 15) // [ 10, 11, 12, 13, 14 ]
 * Range(10, 30, 5) // [ 10, 15, 20, 25 ]
 * Range(30, 10, 5) // [ 30, 25, 20, 15 ]
 * Range(30, 30, 5) // []
 * ```
 * @param {(undefined|number)=} start
 * @param {(undefined|number)=} end
 * @param {(undefined|number)=} step
 * @return {?}
 */
immutable_.Immutable.Range = function(start, end, step) {};

/**
 * Returns a Seq.Indexed of `value` repeated `times` times. When `times` is
 * not defined, returns an infinite `Seq` of `value`.
 * 
 * Note: `Repeat` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * 
 * ```js
 * const { Repeat } = require('immutable')
 * Repeat('foo') // [ 'foo', 'foo', 'foo', ... ]
 * Repeat('bar', 4) // [ 'bar', 'bar', 'bar', 'bar' ]
 * ```
 * @template T
 * @param {T} value
 * @param {(undefined|number)=} times
 * @return {?}
 */
immutable_.Immutable.Repeat = function(value, times) {};

/**
 * True if `maybeRecord` is an instance of a Record.
 * @param {*} maybeRecord
 * @return {boolean}
 */
immutable_.Immutable.Record.isRecord = function(maybeRecord) {};

/**
 * Records allow passing a second parameter to supply a descriptive name
 * that appears when converting a Record to a string or in any error
 * messages. A descriptive name for any record can be accessed by using this
 * method. If one was not provided, the string "Record" is returned.
 * 
 * ```js
 * const { Record } = require('immutable')
 * const Person = Record({
 *   name: null
 * }, 'Person')
 * 
 * var me = Person({ name: 'My Name' })
 * me.toString() // "Person { "name": "My Name" }"
 * Record.getDescriptiveName(me) // "Person"
 * ```
 * @param {?} record
 * @return {string}
 */
immutable_.Immutable.Record.getDescriptiveName = function(record) {};

/* TODO: CallSignature: immutable_.Immutable.Record */

/* TODO: ConstructSignature: immutable_.Immutable.Record */
/** @type {string} */
immutable_.Immutable.Record.Factory.prototype.displayName;

/**
 * @template TProps
 * @param {(undefined|?|!Iterable<!Array<?>>)=} values
 * @return {?}
 */
immutable_.Immutable.Record.Factory = function(values) {};

/**
 * Unlike other types in Immutable.js, the `Record()` function creates a new
 * Record Factory, which is a function that creates Record instances.
 * 
 * See above for examples of using `Record()`.
 * 
 * Note: `Record` is a factory function and not a class, and does not use the
 * `new` keyword during construction.
 * @template TProps
 * @param {TProps} defaultValues
 * @param {(undefined|string)=} name
 * @return {?}
 */
immutable_.Immutable.Record = function(defaultValues, name) {};

/**
 * @public
 * @param {string} key
 * @return {boolean}
 */
immutable_.Immutable.Record.prototype.has = function(key) {};

/**
 * Returns the value associated with the provided key, which may be the
 * default value defined when creating the Record factory function.
 * 
 * If the requested key is not defined by this Record type, then
 * notSetValue will be returned if provided. Note that this scenario would
 * produce an error when using Flow or TypeScript.
 * @public
 * @template K, T
 * @param {K|string} key
 * @param {*|T=} notSetValue
 * @return {?|T}
 */
immutable_.Immutable.Record.prototype.get = function(key, notSetValue) {};

/**
 * @public
 * @param {!Iterable<*>} keyPath
 * @return {boolean}
 */
immutable_.Immutable.Record.prototype.hasIn = function(keyPath) {};

/**
 * @public
 * @param {!Iterable<*>} keyPath
 * @return {*}
 */
immutable_.Immutable.Record.prototype.getIn = function(keyPath) {};

/**
 * @public
 * @param {*} other
 * @return {boolean}
 */
immutable_.Immutable.Record.prototype.equals = function(other) {};

/**
 * @public
 * @return {number}
 */
immutable_.Immutable.Record.prototype.hashCode = function() {};

/**
 * @public
 * @template THIS,K
 * @this {THIS}
 * @param {K} key
 * @param {?} value
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.set = function(key, value) {};

/**
 * @public
 * @template THIS,K
 * @this {THIS}
 * @param {K} key
 * @param {function(?): ?} updater
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.update = function(key, updater) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...(!Iterable<!Array<?>>|?)} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.merge = function(collections) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...(!Iterable<!Array<?>>|?)} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.mergeDeep = function(collections) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(*, *, ?): *} merger
 * @param {...(!Iterable<!Array<?>>|?)} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.mergeWith = function(merger, collections) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(*, *, *): *} merger
 * @param {...(!Iterable<!Array<?>>|?)} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.mergeDeepWith = function(merger, collections) {};

/**
 * Returns a new instance of this Record type with the value for the
 * specific key set to its default value.
 * 
 * \@alias remove
 * @public
 * @template THIS,K
 * @this {THIS}
 * @param {K} key
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.delete = function(key) {};

/**
 * @public
 * @template THIS,K
 * @this {THIS}
 * @param {K} key
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.remove = function(key) {};

/**
 * Returns a new instance of this Record type with all values set
 * to their default values.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.clear = function() {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {*} value
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.setIn = function(keyPath, value) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {function(*): *} updater
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.updateIn = function(keyPath, updater) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.mergeIn = function(keyPath, collections) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @param {...*} collections
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.mergeDeepIn = function(keyPath, collections) {};

/**
 * \@alias removeIn
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.deleteIn = function(keyPath) {};

/**
 * @public
 * @template THIS
 * @this {THIS}
 * @param {!Iterable<*>} keyPath
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.removeIn = function(keyPath) {};

/**
 * Deeply converts this Record to equivalent native JavaScript Object.
 * 
 * Note: This method may not be overridden. Objects with custom
 * serialization to plain JS may override toJSON() instead.
 * @public
 * @return {?}
 */
immutable_.Immutable.Record.prototype.toJS = function() {};

/**
 * Shallowly converts this Record to equivalent native JavaScript Object.
 * @public
 * @return {TProps}
 */
immutable_.Immutable.Record.prototype.toJSON = function() {};

/**
 * Shallowly converts this Record to equivalent JavaScript Object.
 * @public
 * @return {TProps}
 */
immutable_.Immutable.Record.prototype.toObject = function() {};

/**
 * Note: Not all methods can be used on a mutable collection or within
 * `withMutations`! Only `set` may be used mutatively.
 * 
 * @see `Map#withMutations`
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(!immutable.Immutable.Record): *} mutator
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.withMutations = function(mutator) {};

/**
 * @see `Map#asMutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.asMutable = function() {};

/**
 * @see `Map#wasAltered`
 * @public
 * @return {boolean}
 */
immutable_.Immutable.Record.prototype.wasAltered = function() {};

/**
 * @see `Map#asImmutable`
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Record.prototype.asImmutable = function() {};

/**
 * @public
 * @return {?}
 */
immutable_.Immutable.Record.prototype.toSeq = function() {};

/**
 * @public
 * @return {!IterableIterator<!Array<?>>}
 */
immutable_.Immutable.Record.prototype[Symbol.iterator] = function() {};

/** @typedef {?} */
immutable_.Immutable.RecordOf;

/**
 * True if `maybeSeq` is a Seq, it is not backed by a concrete
 * structure such as Map, List, or Set.
 * @param {*} maybeSeq
 * @return {boolean}
 */
immutable_.Immutable.Seq.isSeq = function(maybeSeq) {};

/**
 * Always returns a Seq.Keyed, if input is not keyed, expects an
 * collection of [K, V] tuples.
 * 
 * Note: `Seq.Keyed` is a conversion function and not a class, and does not
 * use the `new` keyword during construction.
 * @template K, V
 * @param {(undefined|!Iterable<!Array<?>>)|!Object<string,V>=} collection_or_obj
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed = function(collection_or_obj) {};

/**
 * Deeply converts this Keyed Seq to equivalent native JavaScript Object.
 * 
 * Converts keys to Strings.
 * @public
 * @return {!Object<string,*>}
 */
immutable_.Immutable.Seq.Keyed.prototype.toJS = function() {};

/**
 * Shallowly converts this Keyed Seq to equivalent native JavaScript Object.
 * 
 * Converts keys to Strings.
 * @public
 * @return {!Object<string,V>}
 */
immutable_.Immutable.Seq.Keyed.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<!Array<?>>}
 */
immutable_.Immutable.Seq.Keyed.prototype.toArray = function() {};

/**
 * Returns itself
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Seq.Keyed.prototype.toSeq = function() {};

/**
 * Returns a new Seq with other collections concatenated to this one.
 * 
 * All entries will be present in the resulting Seq, even if they
 * have the same key.
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.concat = function(collections) {};

/**
 * Returns a new Seq.Keyed with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Seq } = require('immutable')
 * Seq.Keyed({ a: 1, b: 2 }).map(x => 10 * x)
 * // Seq { "a": 10, "b": 20 }
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.Seq.Keyed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.map = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapKeys
 * @public
 * @template M
 * @param {function(K, V, !immutable.Immutable.Seq.Keyed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.mapKeys = function(mapper, context) {};

/**
 * @see Collection.Keyed.mapEntries
 * @public
 * @template KM, VM
 * @param {function(!Array<?>, number, !immutable.Immutable.Seq.Keyed): (undefined|!Array<?>)} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.mapEntries = function(mapper, context) {};

/**
 * Flat-maps the Seq, returning a Seq of the same type.
 * 
 * Similar to `seq.map(...).flatten(true)`.
 * @public
 * @template KM, VM
 * @param {function(V, K, !immutable.Immutable.Seq.Keyed): !Iterable<!Array<?>>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Seq with only the entries for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Seq.Keyed): boolean|function(V, K, !immutable.Immutable.Seq.Keyed): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Seq.Keyed.prototype.filter = function(predicate, context) {};

/**
 * @see Collection.Keyed.flip
 * @public
 * @return {?}
 */
immutable_.Immutable.Seq.Keyed.prototype.flip = function() {};

/**
 * @public
 * @return {!IterableIterator<!Array<?>>}
 */
immutable_.Immutable.Seq.Keyed.prototype[Symbol.iterator] = function() {};

/**
 * Provides an Seq.Indexed of the values provided.
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.of = function(values) {};

/**
 * Always returns Seq.Indexed, discarding associated keys and
 * supplying incrementing indices.
 * 
 * Note: `Seq.Indexed` is a conversion function and not a class, and does
 * not use the `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed = function(collection) {};

/**
 * Deeply converts this Indexed Seq to equivalent native JavaScript Array.
 * @public
 * @return {!Array<*>}
 */
immutable_.Immutable.Seq.Indexed.prototype.toJS = function() {};

/**
 * Shallowly converts this Indexed Seq to equivalent native JavaScript Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Seq.Indexed.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Seq.Indexed.prototype.toArray = function() {};

/**
 * Returns itself
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Seq.Indexed.prototype.toSeq = function() {};

/**
 * Returns a new Seq with other collections concatenated to this one.
 * @public
 * @template C
 * @param {...(C|!Iterable<C>)} valuesOrCollections
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.concat = function(valuesOrCollections) {};

/**
 * Returns a new Seq.Indexed with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Seq } = require('immutable')
 * Seq.Indexed([ 1, 2 ]).map(x => 10 * x)
 * // Seq [ 10, 20 ]
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Seq.Indexed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Seq, returning a a Seq of the same type.
 * 
 * Similar to `seq.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Seq.Indexed): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Seq with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, number, !immutable.Immutable.Seq.Indexed): boolean|function(T, number, !immutable.Immutable.Seq.Indexed): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Seq.Indexed.prototype.filter = function(predicate, context) {};

/**
 * Returns a Seq "zipped" with the provided collections.
 * 
 * Like `zipWith`, but using the default `zipper`: creating an `Array`.
 * 
 * ```js
 * const a = Seq([ 1, 2, 3 ]);
 * const b = Seq([ 4, 5, 6 ]);
 * const c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.zip = function(other_or_collections) {};

/**
 * Returns a Seq "zipped" with the provided collections.
 * 
 * Unlike `zip`, `zipAll` continues zipping until the longest collection is
 * exhausted. Missing values from shorter collections are filled with `undefined`.
 * 
 * ```js
 * const a = Seq([ 1, 2 ]);
 * const b = Seq([ 3, 4, 5 ]);
 * const c = a.zipAll(b); // Seq [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.zipAll = function(other_or_collections) {};

/**
 * Returns a Seq "zipped" with the provided collections by using a
 * custom `zipper` function.
 * 
 * ```js
 * const a = Seq([ 1, 2, 3 ]);
 * const b = Seq([ 4, 5, 6 ]);
 * const c = a.zipWith((a, b) => a + b, b);
 * // Seq [ 5, 7, 9 ]
 * ```
 * @public
 * @template U, Z, V
 * @param {function(T, U): Z|function(T, U, V): Z|function(...*): Z} zipper
 * @param {...?} otherCollection_or_collections
 * @return {?}
 */
immutable_.Immutable.Seq.Indexed.prototype.zipWith = function(zipper, otherCollection_or_collections) {};

/**
 * @public
 * @return {!IterableIterator<T>}
 */
immutable_.Immutable.Seq.Indexed.prototype[Symbol.iterator] = function() {};

/**
 * Returns a Seq.Set of the provided values
 * @template T
 * @param {...T} values
 * @return {?}
 */
immutable_.Immutable.Seq.Set.of = function(values) {};

/**
 * Always returns a Seq.Set, discarding associated indices or keys.
 * 
 * Note: `Seq.Set` is a conversion function and not a class, and does not
 * use the `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Seq.Set = function(collection) {};

/**
 * Deeply converts this Set Seq to equivalent native JavaScript Array.
 * @public
 * @return {!Array<*>}
 */
immutable_.Immutable.Seq.Set.prototype.toJS = function() {};

/**
 * Shallowly converts this Set Seq to equivalent native JavaScript Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Seq.Set.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Seq.Set.prototype.toArray = function() {};

/**
 * Returns itself
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Seq.Set.prototype.toSeq = function() {};

/**
 * Returns a new Seq with other collections concatenated to this one.
 * 
 * All entries will be present in the resulting Seq, even if they
 * are duplicates.
 * @public
 * @template U
 * @param {...!Iterable<U>} collections
 * @return {?}
 */
immutable_.Immutable.Seq.Set.prototype.concat = function(collections) {};

/**
 * Returns a new Seq.Set with values passed through a
 * `mapper` function.
 * 
 * ```js
 * Seq.Set([ 1, 2 ]).map(x => 10 * x)
 * // Seq { 10, 20 }
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Seq.Set): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Set.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Seq, returning a Seq of the same type.
 * 
 * Similar to `seq.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Seq.Set): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.Set.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Seq with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, T, !immutable.Immutable.Seq.Set): boolean|function(T, T, !immutable.Immutable.Seq.Set): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Seq.Set.prototype.filter = function(predicate, context) {};

/**
 * @public
 * @return {!IterableIterator<T>}
 */
immutable_.Immutable.Seq.Set.prototype[Symbol.iterator] = function() {};

/**
 * Creates a Seq.
 * 
 * Returns a particular kind of `Seq` based on the input.
 * 
 *   * If a `Seq`, that same `Seq`.
 *   * If an `Collection`, a `Seq` of the same kind (Keyed, Indexed, or Set).
 *   * If an Array-like, an `Seq.Indexed`.
 *   * If an Iterable Object, an `Seq.Indexed`.
 *   * If an Object, a `Seq.Keyed`.
 * 
 * Note: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,
 * which is usually not what you want. You should turn your Iterator Object into
 * an iterable object by defining a Symbol.iterator (or \@\@iterator) method which
 * returns `this`.
 * 
 * Note: `Seq` is a conversion function and not a class, and does not use the
 * `new` keyword during construction.
 * @template S, K, V, T
 * @param {S|?|(?|!Iterable<T>|!ArrayLike<T>)|!Object<string,V>=} seq_or_collection_or_obj
 * @return {S|?}
 */
immutable_.Immutable.Seq = function(seq_or_collection_or_obj) {};
/** @type {(undefined|number)} */
immutable_.Immutable.Seq.prototype.size;

/**
 * Because Sequences are lazy and designed to be chained together, they do
 * not cache their results. For example, this map function is called a total
 * of 6 times, as each `join` iterates the Seq of three values.
 * 
 *     var squares = Seq([ 1, 2, 3 ]).map(x => x * x)
 *     squares.join() + squares.join()
 * 
 * If you know a `Seq` will be used multiple times, it may be more
 * efficient to first cache it in memory. Here, the map function is called
 * only 3 times.
 * 
 *     var squares = Seq([ 1, 2, 3 ]).map(x => x * x).cacheResult()
 *     squares.join() + squares.join()
 * 
 * Use this method judiciously, as it must fully evaluate a Seq which can be
 * a burden on memory and possibly performance.
 * 
 * Note: after calling `cacheResult`, a Seq will always have a `size`.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Seq.prototype.cacheResult = function() {};

/**
 * Returns a new Seq with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Seq } = require('immutable')
 * Seq([ 1, 2 ]).map(x => 10 * x)
 * // Seq [ 10, 20 ]
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the same
 * value at every step. / Returns a new Seq with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Seq } = require('immutable')
 * Seq([ 1, 2 ]).map(x => 10 * x)
 * // Seq [ 10, 20 ]
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the same
 * value at every step.
 * Note: used only for sets.
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.Seq): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Seq, returning a Seq of the same type.
 * 
 * Similar to `seq.map(...).flatten(true)`. / Flat-maps the Seq, returning a Seq of the same type.
 * 
 * Similar to `seq.map(...).flatten(true)`.
 * Note: Used only for sets.
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.Seq): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Seq.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Seq with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Seq): boolean|function(V, K, !immutable.Immutable.Seq): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Seq.prototype.filter = function(predicate, context) {};

/**
 * @deprecated use `const { isKeyed } = require('immutable')`
 * @param {*} maybeKeyed
 * @return {boolean}
 */
immutable_.Immutable.Collection.isKeyed = function(maybeKeyed) {};

/**
 * @deprecated use `const { isIndexed } = require('immutable')`
 * @param {*} maybeIndexed
 * @return {boolean}
 */
immutable_.Immutable.Collection.isIndexed = function(maybeIndexed) {};

/**
 * @deprecated use `const { isAssociative } = require('immutable')`
 * @param {*} maybeAssociative
 * @return {boolean}
 */
immutable_.Immutable.Collection.isAssociative = function(maybeAssociative) {};

/**
 * @deprecated use `const { isOrdered } = require('immutable')`
 * @param {*} maybeOrdered
 * @return {boolean}
 */
immutable_.Immutable.Collection.isOrdered = function(maybeOrdered) {};

/**
 * Creates a Collection.Keyed
 * 
 * Similar to `Collection()`, however it expects collection-likes of [K, V]
 * tuples if not constructed from a Collection.Keyed or JS Object.
 * 
 * Note: `Collection.Keyed` is a conversion function and not a class, and
 * does not use the `new` keyword during construction.
 * @template K, V
 * @param {(undefined|!Iterable<!Array<?>>)|!Object<string,V>=} collection_or_obj
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed = function(collection_or_obj) {};

/**
 * Deeply converts this Keyed collection to equivalent native JavaScript Object.
 * 
 * Converts keys to Strings.
 * @public
 * @return {!Object<string,*>}
 */
immutable_.Immutable.Collection.Keyed.prototype.toJS = function() {};

/**
 * Shallowly converts this Keyed collection to equivalent native JavaScript Object.
 * 
 * Converts keys to Strings.
 * @public
 * @return {!Object<string,V>}
 */
immutable_.Immutable.Collection.Keyed.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<!Array<?>>}
 */
immutable_.Immutable.Collection.Keyed.prototype.toArray = function() {};

/**
 * Returns Seq.Keyed.
 * @override
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.toSeq = function() {};

/**
 * Returns a new Collection.Keyed of the same type where the keys and values
 * have been flipped.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ a: 'z', b: 'y' }).flip()
 * // Map { "z": "a", "y": "b" }
 * ```
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.flip = function() {};

/**
 * Returns a new Collection with other collections concatenated to this one.
 * @public
 * @template KC, VC, C
 * @param {...!Iterable<!Array<?>>|!Object<string,C>} collections
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.concat = function(collections) {};

/**
 * Returns a new Collection.Keyed with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Collection } = require('immutable')
 * Collection.Keyed({ a: 1, b: 2 }).map(x => 10 * x)
 * // Seq { "a": 10, "b": 20 }
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(V, K, !immutable.Immutable.Collection.Keyed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.map = function(mapper, context) {};

/**
 * Returns a new Collection.Keyed of the same type with keys passed through
 * a `mapper` function.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ a: 1, b: 2 }).mapKeys(x => x.toUpperCase())
 * // Map { "A": 1, "B": 2 }
 * ```
 * 
 * Note: `mapKeys()` always returns a new instance, even if it produced
 * the same key at every step.
 * @public
 * @template M
 * @param {function(K, V, !immutable.Immutable.Collection.Keyed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.mapKeys = function(mapper, context) {};

/**
 * Returns a new Collection.Keyed of the same type with entries
 * ([key, value] tuples) passed through a `mapper` function.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ a: 1, b: 2 })
 *   .mapEntries(([ k, v ]) => [ k.toUpperCase(), v * 2 ])
 * // Map { "A": 2, "B": 4 }
 * ```
 * 
 * Note: `mapEntries()` always returns a new instance, even if it produced
 * the same entry at every step.
 * 
 * If the mapper function returns `undefined`, then the entry will be filtered
 * @public
 * @template KM, VM
 * @param {function(!Array<?>, number, !immutable.Immutable.Collection.Keyed): (undefined|!Array<?>)} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.mapEntries = function(mapper, context) {};

/**
 * Flat-maps the Collection, returning a Collection of the same type.
 * 
 * Similar to `collection.map(...).flatten(true)`.
 * @public
 * @template KM, VM
 * @param {function(V, K, !immutable.Immutable.Collection.Keyed): !Iterable<!Array<?>>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Keyed.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Collection with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection.Keyed): boolean|function(V, K, !immutable.Immutable.Collection.Keyed): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Collection.Keyed.prototype.filter = function(predicate, context) {};

/**
 * @public
 * @return {!IterableIterator<!Array<?>>}
 */
immutable_.Immutable.Collection.Keyed.prototype[Symbol.iterator] = function() {};

/**
 * Creates a new Collection.Indexed.
 * 
 * Note: `Collection.Indexed` is a conversion function and not a class, and
 * does not use the `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed = function(collection) {};

/**
 * Deeply converts this Indexed collection to equivalent native JavaScript Array.
 * @public
 * @return {!Array<*>}
 */
immutable_.Immutable.Collection.Indexed.prototype.toJS = function() {};

/**
 * Shallowly converts this Indexed collection to equivalent native JavaScript Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Collection.Indexed.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Collection.Indexed.prototype.toArray = function() {};

/**
 * Returns the value associated with the provided index, or notSetValue if
 * the index is beyond the bounds of the Collection.
 * 
 * `index` may be a negative number, which indexes back from the end of the
 * Collection. `s.get(-1)` gets the last item in the Collection.
 * @public
 * @template NSV
 * @param {number} index
 * @param {NSV=} notSetValue
 * @return {(T|NSV)|(undefined|T)}
 */
immutable_.Immutable.Collection.Indexed.prototype.get = function(index, notSetValue) {};

/**
 * Returns Seq.Indexed.
 * @override
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.toSeq = function() {};

/**
 * If this is a collection of [key, value] entry tuples, it will return a
 * Seq.Keyed of those entries.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.fromEntrySeq = function() {};

/**
 * Returns a Collection of the same type with `separator` between each item
 * in this Collection.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {T} separator
 * @return {THIS}
 */
immutable_.Immutable.Collection.Indexed.prototype.interpose = function(separator) {};

/**
 * Returns a Collection of the same type with the provided `collections`
 * interleaved into this collection.
 * 
 * The resulting Collection includes the first item from each, then the
 * second from each, etc.
 * 
 * <!-- runkit:activate
 *      { "preamble": "require('immutable')"}
 * -->
 * ```js
 * const { List } = require('immutable')
 * List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
 * // List [ 1, "A", 2, "B", 3, "C" ]
 * ```
 * 
 * The shortest Collection stops interleave.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable')" }
 * -->
 * ```js
 * List([ 1, 2, 3 ]).interleave(
 *   List([ 'A', 'B' ]),
 *   List([ 'X', 'Y', 'Z' ])
 * )
 * // List [ 1, "A", "X", 2, "B", "Y" ]
 * ```
 * 
 * Since `interleave()` re-indexes values, it produces a complete copy,
 * which has `O(N)` complexity.
 * 
 * Note: `interleave` *cannot* be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {...?} collections
 * @return {THIS}
 */
immutable_.Immutable.Collection.Indexed.prototype.interleave = function(collections) {};

/**
 * Splice returns a new indexed Collection by replacing a region of this
 * Collection with new values. If values are not provided, it only skips the
 * region to be removed.
 * 
 * `index` may be a negative number, which indexes back from the end of the
 * Collection. `s.splice(-2)` splices after the second to last item.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
 * // List [ "a", "q", "r", "s", "d" ]
 * ```
 * 
 * Since `splice()` re-indexes values, it produces a complete copy, which
 * has `O(N)` complexity.
 * 
 * Note: `splice` *cannot* be used in `withMutations`.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {number} index
 * @param {number} removeNum
 * @param {...T} values
 * @return {THIS}
 */
immutable_.Immutable.Collection.Indexed.prototype.splice = function(index, removeNum, values) {};

/**
 * Returns a Collection of the same type "zipped" with the provided
 * collections.
 * 
 * Like `zipWith`, but using the default `zipper`: creating an `Array`.
 * 
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable')" }
 * -->
 * ```js
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 4, 5, 6 ]);
 * const c = a.zip(b); // List [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.zip = function(other_or_collections) {};

/**
 * Returns a Collection "zipped" with the provided collections.
 * 
 * Unlike `zip`, `zipAll` continues zipping until the longest collection is
 * exhausted. Missing values from shorter collections are filled with `undefined`.
 * 
 * ```js
 * const a = List([ 1, 2 ]);
 * const b = List([ 3, 4, 5 ]);
 * const c = a.zipAll(b); // List [ [ 1, 3 ], [ 2, 4 ], [ undefined, 5 ] ]
 * ```
 * @public
 * @template U, V
 * @param {...?} other_or_collections
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.zipAll = function(other_or_collections) {};

/**
 * Returns a Collection of the same type "zipped" with the provided
 * collections by using a custom `zipper` function.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { List } = require('immutable')" }
 * -->
 * ```js
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 4, 5, 6 ]);
 * const c = a.zipWith((a, b) => a + b, b);
 * // List [ 5, 7, 9 ]
 * ```
 * @public
 * @template U, Z, V
 * @param {function(T, U): Z|function(T, U, V): Z|function(...*): Z} zipper
 * @param {...?} otherCollection_or_collections
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.zipWith = function(zipper, otherCollection_or_collections) {};

/**
 * Returns the first index at which a given value can be found in the
 * Collection, or -1 if it is not present.
 * @public
 * @param {T} searchValue
 * @return {number}
 */
immutable_.Immutable.Collection.Indexed.prototype.indexOf = function(searchValue) {};

/**
 * Returns the last index at which a given value can be found in the
 * Collection, or -1 if it is not present.
 * @public
 * @param {T} searchValue
 * @return {number}
 */
immutable_.Immutable.Collection.Indexed.prototype.lastIndexOf = function(searchValue) {};

/**
 * Returns the first index in the Collection where a value satisfies the
 * provided predicate function. Otherwise -1 is returned.
 * @public
 * @param {function(T, number, !immutable.Immutable.Collection.Indexed): boolean} predicate
 * @param {*=} context
 * @return {number}
 */
immutable_.Immutable.Collection.Indexed.prototype.findIndex = function(predicate, context) {};

/**
 * Returns the last index in the Collection where a value satisfies the
 * provided predicate function. Otherwise -1 is returned.
 * @public
 * @param {function(T, number, !immutable.Immutable.Collection.Indexed): boolean} predicate
 * @param {*=} context
 * @return {number}
 */
immutable_.Immutable.Collection.Indexed.prototype.findLastIndex = function(predicate, context) {};

/**
 * Returns a new Collection with other collections concatenated to this one.
 * @public
 * @template C
 * @param {...(C|!Iterable<C>)} valuesOrCollections
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.concat = function(valuesOrCollections) {};

/**
 * Returns a new Collection.Indexed with values passed through a
 * `mapper` function.
 * 
 * ```js
 * const { Collection } = require('immutable')
 * Collection.Indexed([1,2]).map(x => 10 * x)
 * // Seq [ 1, 2 ]
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Collection.Indexed): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Collection, returning a Collection of the same type.
 * 
 * Similar to `collection.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, number, !immutable.Immutable.Collection.Indexed): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Indexed.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Collection with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, number, !immutable.Immutable.Collection.Indexed): boolean|function(T, number, !immutable.Immutable.Collection.Indexed): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Collection.Indexed.prototype.filter = function(predicate, context) {};

/**
 * @public
 * @return {!IterableIterator<T>}
 */
immutable_.Immutable.Collection.Indexed.prototype[Symbol.iterator] = function() {};

/**
 * Similar to `Collection()`, but always returns a Collection.Set.
 * 
 * Note: `Collection.Set` is a factory function and not a class, and does
 * not use the `new` keyword during construction.
 * @template T
 * @param {(undefined|!Iterable<T>|!ArrayLike<T>)=} collection
 * @return {?}
 */
immutable_.Immutable.Collection.Set = function(collection) {};

/**
 * Deeply converts this Set collection to equivalent native JavaScript Array.
 * @public
 * @return {!Array<*>}
 */
immutable_.Immutable.Collection.Set.prototype.toJS = function() {};

/**
 * Shallowly converts this Set collection to equivalent native JavaScript Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Collection.Set.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * @public
 * @return {!Array<T>}
 */
immutable_.Immutable.Collection.Set.prototype.toArray = function() {};

/**
 * Returns Seq.Set.
 * @override
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.Set.prototype.toSeq = function() {};

/**
 * Returns a new Collection with other collections concatenated to this one.
 * @public
 * @template U
 * @param {...!Iterable<U>} collections
 * @return {?}
 */
immutable_.Immutable.Collection.Set.prototype.concat = function(collections) {};

/**
 * Returns a new Collection.Set with values passed through a
 * `mapper` function.
 * 
 * ```
 * Collection.Set([ 1, 2 ]).map(x => 10 * x)
 * // Seq { 1, 2 }
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the
 * same value at every step.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Collection.Set): M} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Set.prototype.map = function(mapper, context) {};

/**
 * Flat-maps the Collection, returning a Collection of the same type.
 * 
 * Similar to `collection.map(...).flatten(true)`.
 * @public
 * @template M
 * @param {function(T, T, !immutable.Immutable.Collection.Set): !Iterable<M>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.Set.prototype.flatMap = function(mapper, context) {};

/**
 * Returns a new Collection with only the values for which the `predicate`
 * function returns true.
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(T, T, !immutable.Immutable.Collection.Set): boolean|function(T, T, !immutable.Immutable.Collection.Set): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Collection.Set.prototype.filter = function(predicate, context) {};

/**
 * @public
 * @return {!IterableIterator<T>}
 */
immutable_.Immutable.Collection.Set.prototype[Symbol.iterator] = function() {};

/**
 * Creates a Collection.
 * 
 * The type of Collection created is based on the input.
 * 
 *   * If an `Collection`, that same `Collection`.
 *   * If an Array-like, an `Collection.Indexed`.
 *   * If an Object with an Iterator defined, an `Collection.Indexed`.
 *   * If an Object, an `Collection.Keyed`.
 * 
 * This methods forces the conversion of Objects and Strings to Collections.
 * If you want to ensure that a Collection of one item is returned, use
 * `Seq.of`.
 * 
 * Note: An Iterator itself will be treated as an object, becoming a `Seq.Keyed`,
 * which is usually not what you want. You should turn your Iterator Object into
 * an iterable object by defining a Symbol.iterator (or \@\@iterator) method which
 * returns `this`.
 * 
 * Note: `Collection` is a conversion function and not a class, and does not
 * use the `new` keyword during construction.
 * @template I, T, V, K
 * @param {I|(!Iterable<T>|!ArrayLike<T>)|!Object<string,V>=} collection_or_obj
 * @return {I|?}
 */
immutable_.Immutable.Collection = function(collection_or_obj) {};

/**
 * True if this and the other Collection have value equality, as defined
 * by `Immutable.is()`.
 * 
 * Note: This is equivalent to `Immutable.is(this, other)`, but provided to
 * allow for chained expressions.
 * @public
 * @param {*} other
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.equals = function(other) {};

/**
 * Computes and returns the hashed identity for this Collection.
 * 
 * The `hashCode` of a Collection is used to determine potential equality,
 * and is used when adding this to a `Set` or as a key in a `Map`, enabling
 * lookup via a different instance.
 * 
 * <!-- runkit:activate
 *      { "preamble": "const { Set,  List } = require('immutable')" }
 * -->
 * ```js
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 1, 2, 3 ]);
 * assert.notStrictEqual(a, b); // different instances
 * const set = Set([ a ]);
 * assert.equal(set.has(b), true);
 * ```
 * 
 * If two values have the same `hashCode`, they are [not guaranteed
 * to be equal][Hash Collision]. If two values have different `hashCode`s,
 * they must not be equal.
 * 
 * [Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)
 * @public
 * @return {number}
 */
immutable_.Immutable.Collection.prototype.hashCode = function() {};

/**
 * Returns the value associated with the provided key, or notSetValue if
 * the Collection does not contain this key.
 * 
 * Note: it is possible a key may be associated with an `undefined` value,
 * so if `notSetValue` is not provided and this method returns `undefined`,
 * that does not guarantee the key was not found.
 * @public
 * @template NSV
 * @param {K} key
 * @param {NSV=} notSetValue
 * @return {(V|NSV)|(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.get = function(key, notSetValue) {};

/**
 * True if a key exists within this `Collection`, using `Immutable.is`
 * to determine equality
 * @public
 * @param {K} key
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.has = function(key) {};

/**
 * True if a value exists within this `Collection`, using `Immutable.is`
 * to determine equality
 * \@alias contains
 * @public
 * @param {V} value
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.includes = function(value) {};

/**
 * @public
 * @param {V} value
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.contains = function(value) {};

/**
 * In case the `Collection` is not empty returns the first element of the
 * `Collection`.
 * In case the `Collection` is empty returns the optional default
 * value if provided, if no default value is provided returns undefined.
 * @public
 * @template NSV
 * @param {(undefined|NSV)=} notSetValue
 * @return {(V|NSV)}
 */
immutable_.Immutable.Collection.prototype.first = function(notSetValue) {};

/**
 * In case the `Collection` is not empty returns the last element of the
 * `Collection`.
 * In case the `Collection` is empty returns the optional default
 * value if provided, if no default value is provided returns undefined.
 * @public
 * @template NSV
 * @param {(undefined|NSV)=} notSetValue
 * @return {(V|NSV)}
 */
immutable_.Immutable.Collection.prototype.last = function(notSetValue) {};

/**
 * Returns the value found by following a path of keys or indices through
 * nested Collections.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map, List } = require('immutable')
 * const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
 * deepData.getIn(['x', 0, 'y']) // 123
 * ```
 * 
 * Plain JavaScript Object or Arrays may be nested within an Immutable.js
 * Collection, and getIn() can access those values as well:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map, List } = require('immutable')
 * const deepData = Map({ x: [ { y: 123 } ] });
 * deepData.getIn(['x', 0, 'y']) // 123
 * ```
 * @public
 * @param {!Iterable<*>} searchKeyPath
 * @param {*=} notSetValue
 * @return {*}
 */
immutable_.Immutable.Collection.prototype.getIn = function(searchKeyPath, notSetValue) {};

/**
 * True if the result of following a path of keys or indices through nested
 * Collections results in a set value.
 * @public
 * @param {!Iterable<*>} searchKeyPath
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.hasIn = function(searchKeyPath) {};

/**
 * This can be very useful as a way to "chain" a normal function into a
 * sequence of methods. RxJS calls this "let" and lodash calls it "thru".
 * 
 * For example, to sum a Seq after mapping and filtering:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Seq } = require('immutable')
 * 
 * function sum(collection) {
 *   return collection.reduce((sum, x) => sum + x, 0)
 * }
 * 
 * Seq([ 1, 2, 3 ])
 *   .map(x => x + 1)
 *   .filter(x => x % 2 === 0)
 *   .update(sum)
 * // 6
 * ```
 * @public
 * @template R
 * @param {function(!immutable.Immutable.Collection): R} updater
 * @return {R}
 */
immutable_.Immutable.Collection.prototype.update = function(updater) {};

/**
 * Deeply converts this Collection to equivalent native JavaScript Array or Object.
 * 
 * `Collection.Indexed`, and `Collection.Set` become `Array`, while
 * `Collection.Keyed` become `Object`, converting keys to Strings.
 * @public
 * @return {(!Array<*>|!Object<string,*>)}
 */
immutable_.Immutable.Collection.prototype.toJS = function() {};

/**
 * Shallowly converts this Collection to equivalent native JavaScript Array or Object.
 * 
 * `Collection.Indexed`, and `Collection.Set` become `Array`, while
 * `Collection.Keyed` become `Object`, converting keys to Strings.
 * @public
 * @return {(!Array<V>|!Object<string,V>)}
 */
immutable_.Immutable.Collection.prototype.toJSON = function() {};

/**
 * Shallowly converts this collection to an Array.
 * 
 * `Collection.Indexed`, and `Collection.Set` produce an Array of values.
 * `Collection.Keyed` produce an Array of [key, value] tuples.
 * @public
 * @return {(!Array<V>|!Array<!Array<?>>)}
 */
immutable_.Immutable.Collection.prototype.toArray = function() {};

/**
 * Shallowly converts this Collection to an Object.
 * 
 * Converts keys to Strings.
 * @public
 * @return {!Object<string,V>}
 */
immutable_.Immutable.Collection.prototype.toObject = function() {};

/**
 * Converts this Collection to a Map, Throws if keys are not hashable.
 * 
 * Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided
 * for convenience and to allow for chained expressions.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toMap = function() {};

/**
 * Converts this Collection to a Map, maintaining the order of iteration.
 * 
 * Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but
 * provided for convenience and to allow for chained expressions.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toOrderedMap = function() {};

/**
 * Converts this Collection to a Set, discarding keys. Throws if values
 * are not hashable.
 * 
 * Note: This is equivalent to `Set(this)`, but provided to allow for
 * chained expressions.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toSet = function() {};

/**
 * Converts this Collection to a Set, maintaining the order of iteration and
 * discarding keys.
 * 
 * Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided
 * for convenience and to allow for chained expressions.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toOrderedSet = function() {};

/**
 * Converts this Collection to a List, discarding keys.
 * 
 * This is similar to `List(collection)`, but provided to allow for chained
 * expressions. However, when called on `Map` or other keyed collections,
 * `collection.toList()` discards the keys and creates a list of only the
 * values, whereas `List(collection)` creates a list of entry tuples.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map, List } = require('immutable')
 * var myMap = Map({ a: 'Apple', b: 'Banana' })
 * List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
 * myMap.toList() // List [ "Apple", "Banana" ]
 * ```
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toList = function() {};

/**
 * Converts this Collection to a Stack, discarding keys. Throws if values
 * are not hashable.
 * 
 * Note: This is equivalent to `Stack(this)`, but provided to allow for
 * chained expressions.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toStack = function() {};

/**
 * Converts this Collection to a Seq of the same kind (indexed,
 * keyed, or set).
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toSeq = function() {};

/**
 * Returns a Seq.Keyed from this Collection where indices are treated as keys.
 * 
 * This is useful if you want to operate on an
 * Collection.Indexed and preserve the [index, value] pairs.
 * 
 * The returned Seq will have identical iteration order as
 * this Collection.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Seq } = require('immutable')
 * const indexedSeq = Seq([ 'A', 'B', 'C' ])
 * // Seq [ "A", "B", "C" ]
 * indexedSeq.filter(v => v === 'B')
 * // Seq [ "B" ]
 * const keyedSeq = indexedSeq.toKeyedSeq()
 * // Seq { 0: "A", 1: "B", 2: "C" }
 * keyedSeq.filter(v => v === 'B')
 * // Seq { 1: "B" }
 * ```
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toKeyedSeq = function() {};

/**
 * Returns an Seq.Indexed of the values of this Collection, discarding keys.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toIndexedSeq = function() {};

/**
 * Returns a Seq.Set of the values of this Collection, discarding keys.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.toSetSeq = function() {};

/**
 * An iterator of this `Collection`'s keys.
 * 
 * Note: this will return an ES6 iterator which does not support
 * Immutable.js sequence algorithms. Use `keySeq` instead, if this is
 * what you want.
 * @public
 * @return {!IterableIterator<K>}
 */
immutable_.Immutable.Collection.prototype.keys = function() {};

/**
 * An iterator of this `Collection`'s values.
 * 
 * Note: this will return an ES6 iterator which does not support
 * Immutable.js sequence algorithms. Use `valueSeq` instead, if this is
 * what you want.
 * @public
 * @return {!IterableIterator<V>}
 */
immutable_.Immutable.Collection.prototype.values = function() {};

/**
 * An iterator of this `Collection`'s entries as `[ key, value ]` tuples.
 * 
 * Note: this will return an ES6 iterator which does not support
 * Immutable.js sequence algorithms. Use `entrySeq` instead, if this is
 * what you want.
 * @public
 * @return {!IterableIterator<!Array<?>>}
 */
immutable_.Immutable.Collection.prototype.entries = function() {};

/**
 * @public
 * @return {!IterableIterator<*>}
 */
immutable_.Immutable.Collection.prototype[Symbol.iterator] = function() {};

/**
 * Returns a new Seq.Indexed of the keys of this Collection,
 * discarding values.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.keySeq = function() {};

/**
 * Returns an Seq.Indexed of the values of this Collection, discarding keys.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.valueSeq = function() {};

/**
 * Returns a new Seq.Indexed of [key, value] tuples.
 * @public
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.entrySeq = function() {};

/**
 * Returns a new Collection of the same type with values passed through a
 * `mapper` function.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Collection } = require('immutable')
 * Collection({ a: 1, b: 2 }).map(x => 10 * x)
 * // Seq { "a": 10, "b": 20 }
 * ```
 * 
 * Note: `map()` always returns a new instance, even if it produced the same
 * value at every step. / Note: used only for sets, which return Collection<M, M> but are otherwise
 * identical to normal `map()`.
 * 
 * @public
 * @ignore
 * @template M
 * @param {...function(V, K, !immutable.Immutable.Collection): M|?} mapper_or_args
 * @return {?|*}
 */
immutable_.Immutable.Collection.prototype.map = function(mapper_or_args) {};

/**
 * Returns a new Collection of the same type with only the entries for which
 * the `predicate` function returns true.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ a: 1, b: 2, c: 3, d: 4}).filter(x => x % 2 === 0)
 * // Map { "b": 2, "d": 4 }
 * ```
 * 
 * Note: `filter()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS,F
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean|function(V, K, !immutable.Immutable.Collection): *} predicate
 * @param {*=} context
 * @return {?|THIS}
 */
immutable_.Immutable.Collection.prototype.filter = function(predicate, context) {};

/**
 * Returns a new Collection of the same type with only the entries for which
 * the `predicate` function returns false.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x => x % 2 === 0)
 * // Map { "a": 1, "c": 3 }
 * ```
 * 
 * Note: `filterNot()` always returns a new instance, even if it results in
 * not filtering out any values.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.filterNot = function(predicate, context) {};

/**
 * Returns a new Collection of the same type in reverse order.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.reverse = function() {};

/**
 * Returns a new Collection of the same type which includes the same entries,
 * stably sorted by using a `comparator`.
 * 
 * If a `comparator` is not provided, a default comparator uses `<` and `>`.
 * 
 * `comparator(valueA, valueB)`:
 * 
 *   * Returns `0` if the elements should not be swapped.
 *   * Returns `-1` (or any negative number) if `valueA` comes before `valueB`
 *   * Returns `1` (or any positive number) if `valueA` comes after `valueB`
 *   * Is pure, i.e. it must always return the same value for the same pair
 *     of values.
 * 
 * When sorting collections which have no defined order, their ordered
 * equivalents will be returned. e.g. `map.sort()` returns OrderedMap.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) => {
 *   if (a < b) { return -1; }
 *   if (a > b) { return 1; }
 *   if (a === b) { return 0; }
 * });
 * // OrderedMap { "a": 1, "b": 2, "c": 3 }
 * ```
 * 
 * Note: `sort()` Always returns a new instance, even if the original was
 * already sorted.
 * 
 * Note: This is always an eager operation.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {(undefined|function(V, V): number)=} comparator
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.sort = function(comparator) {};

/**
 * Like `sort`, but also accepts a `comparatorValueMapper` which allows for
 * sorting by more sophisticated means:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * const beattles = Map({
 *   John: { name: "Lennon" },
 *   Paul: { name: "McCartney" },
 *   George: { name: "Harrison" },
 *   Ringo: { name: "Starr" },
 * });
 * beattles.sortBy(member => member.name);
 * ```
 * 
 * Note: `sortBy()` Always returns a new instance, even if the original was
 * already sorted.
 * 
 * Note: This is always an eager operation.
 * @public
 * @template THIS,C
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): C} comparatorValueMapper
 * @param {(undefined|function(C, C): number)=} comparator
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.sortBy = function(comparatorValueMapper, comparator) {};

/**
 * Returns a `Collection.Keyed` of `Collection.Keyeds`, grouped by the return
 * value of the `grouper` function.
 * 
 * Note: This is always an eager operation.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List, Map } = require('immutable')
 * const listOfMaps = List([
 *   Map({ v: 0 }),
 *   Map({ v: 1 }),
 *   Map({ v: 1 }),
 *   Map({ v: 0 }),
 *   Map({ v: 2 })
 * ])
 * const groupsOfMaps = listOfMaps.groupBy(x => x.get('v'))
 * // Map {
 * //   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
 * //   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
 * //   2: List [ Map{ "v": 2 } ],
 * // }
 * ```
 * @public
 * @template G
 * @param {function(V, K, !immutable.Immutable.Collection): G} grouper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.groupBy = function(grouper, context) {};

/**
 * The `sideEffect` is executed for every entry in the Collection.
 * 
 * Unlike `Array#forEach`, if any call of `sideEffect` returns
 * `false`, the iteration will stop. Returns the number of entries iterated
 * (including the last iteration which returned false).
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): *} sideEffect
 * @param {*=} context
 * @return {number}
 */
immutable_.Immutable.Collection.prototype.forEach = function(sideEffect, context) {};

/**
 * Returns a new Collection of the same type representing a portion of this
 * Collection from start up to but not including end.
 * 
 * If begin is negative, it is offset from the end of the Collection. e.g.
 * `slice(-2)` returns a Collection of the last two entries. If it is not
 * provided the new Collection will begin at the beginning of this Collection.
 * 
 * If end is negative, it is offset from the end of the Collection. e.g.
 * `slice(0, -1)` returns a Collection of everything but the last entry. If
 * it is not provided, the new Collection will continue through the end of
 * this Collection.
 * 
 * If the requested slice is equivalent to the current Collection, then it
 * will return itself.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {(undefined|number)=} begin
 * @param {(undefined|number)=} end
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.slice = function(begin, end) {};

/**
 * Returns a new Collection of the same type containing all entries except
 * the first.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.rest = function() {};

/**
 * Returns a new Collection of the same type containing all entries except
 * the last.
 * @public
 * @template THIS
 * @this {THIS}
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.butLast = function() {};

/**
 * Returns a new Collection of the same type which excludes the first `amount`
 * entries from this Collection.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {number} amount
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.skip = function(amount) {};

/**
 * Returns a new Collection of the same type which excludes the last `amount`
 * entries from this Collection.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {number} amount
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.skipLast = function(amount) {};

/**
 * Returns a new Collection of the same type which includes entries starting
 * from when `predicate` first returns false.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
 *   .skipWhile(x => x.match(/g/))
 * // List [ "cat", "hat", "god" ]
 * ```
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.skipWhile = function(predicate, context) {};

/**
 * Returns a new Collection of the same type which includes entries starting
 * from when `predicate` first returns true.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
 *   .skipUntil(x => x.match(/hat/))
 * // List [ "hat", "god" ]
 * ```
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.skipUntil = function(predicate, context) {};

/**
 * Returns a new Collection of the same type which includes the first `amount`
 * entries from this Collection.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {number} amount
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.take = function(amount) {};

/**
 * Returns a new Collection of the same type which includes the last `amount`
 * entries from this Collection.
 * @public
 * @template THIS
 * @this {THIS}
 * @param {number} amount
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.takeLast = function(amount) {};

/**
 * Returns a new Collection of the same type which includes entries from this
 * Collection as long as the `predicate` returns true.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
 *   .takeWhile(x => x.match(/o/))
 * // List [ "dog", "frog" ]
 * ```
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.takeWhile = function(predicate, context) {};

/**
 * Returns a new Collection of the same type which includes entries from this
 * Collection as long as the `predicate` returns false.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List } = require('immutable')
 * List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
 *   .takeUntil(x => x.match(/at/))
 * // List [ "dog", "frog" ]
 * ```
 * @public
 * @template THIS
 * @this {THIS}
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {THIS}
 */
immutable_.Immutable.Collection.prototype.takeUntil = function(predicate, context) {};

/**
 * Returns a new Collection of the same type with other values and
 * collection-like concatenated to this one.
 * 
 * For Seqs, all entries will be present in the resulting Seq, even if they
 * have the same key.
 * @public
 * @param {...*} valuesOrCollections
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.concat = function(valuesOrCollections) {};

/**
 * Flattens nested Collections.
 * 
 * Will deeply flatten the Collection by default, returning a Collection of the
 * same type, but a `depth` can be provided in the form of a number or
 * boolean (where true means to shallowly flatten one level). A depth of 0
 * (or shallow: false) will deeply flatten.
 * 
 * Flattens only others Collection, not Arrays or Objects.
 * 
 * Note: `flatten(true)` operates on Collection<unknown, Collection<K, V>> and
 * returns Collection<K, V>
 * @public
 * @param {(undefined|number)|(undefined|boolean)=} depth_or_shallow
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.flatten = function(depth_or_shallow) {};

/**
 * Flat-maps the Collection, returning a Collection of the same type.
 * 
 * Similar to `collection.map(...).flatten(true)`. / Flat-maps the Collection, returning a Collection of the same type.
 * 
 * Similar to `collection.map(...).flatten(true)`.
 * Used for Dictionaries only.
 * @public
 * @template M, KM, VM
 * @param {function(V, K, !immutable.Immutable.Collection): !Iterable<M>|function(V, K, !immutable.Immutable.Collection): !Iterable<!Array<?>>} mapper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.flatMap = function(mapper, context) {};

/**
 * Reduces the Collection to a value by calling the `reducer` for every entry
 * in the Collection and passing along the reduced value.
 * 
 * If `initialReduction` is not provided, the first item in the
 * Collection will be used.
 * 
 * @see `Array#reduce`.
 * @public
 * @template R
 * @param {function(R, V, K, !immutable.Immutable.Collection): R|function((V|R), V, K, !immutable.Immutable.Collection): R} reducer
 * @param {R=} initialReduction
 * @param {*=} context
 * @return {R}
 */
immutable_.Immutable.Collection.prototype.reduce = function(reducer, initialReduction, context) {};

/**
 * Reduces the Collection in reverse (from the right side).
 * 
 * Note: Similar to this.reverse().reduce(), and provided for parity
 * with `Array#reduceRight`.
 * @public
 * @template R
 * @param {function(R, V, K, !immutable.Immutable.Collection): R|function((V|R), V, K, !immutable.Immutable.Collection): R} reducer
 * @param {R=} initialReduction
 * @param {*=} context
 * @return {R}
 */
immutable_.Immutable.Collection.prototype.reduceRight = function(reducer, initialReduction, context) {};

/**
 * True if `predicate` returns true for all entries in the Collection.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.every = function(predicate, context) {};

/**
 * True if `predicate` returns true for any entry in the Collection.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.some = function(predicate, context) {};

/**
 * Joins values together as a string, inserting a separator between each.
 * The default separator is `","`.
 * @public
 * @param {(undefined|string)=} separator
 * @return {string}
 */
immutable_.Immutable.Collection.prototype.join = function(separator) {};

/**
 * Returns true if this Collection includes no values.
 * 
 * For some lazy `Seq`, `isEmpty` might need to iterate to determine
 * emptiness. At most one iteration will occur.
 * @public
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.isEmpty = function() {};

/**
 * Returns the size of this Collection.
 * 
 * Regardless of if this Collection can describe its size lazily (some Seqs
 * cannot), this method will always return the correct size. E.g. it
 * evaluates a lazy `Seq` if necessary.
 * 
 * If `predicate` is provided, then this returns the count of entries in the
 * Collection for which the `predicate` returns true.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean=} predicate
 * @param {*=} context
 * @return {number}
 */
immutable_.Immutable.Collection.prototype.count = function(predicate, context) {};

/**
 * Returns a `Seq.Keyed` of counts, grouped by the return value of
 * the `grouper` function.
 * 
 * Note: This is not a lazy operation.
 * @public
 * @template G
 * @param {function(V, K, !immutable.Immutable.Collection): G} grouper
 * @param {*=} context
 * @return {?}
 */
immutable_.Immutable.Collection.prototype.countBy = function(grouper, context) {};

/**
 * Returns the first value for which the `predicate` returns true.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @param {(undefined|V)=} notSetValue
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.find = function(predicate, context, notSetValue) {};

/**
 * Returns the last value for which the `predicate` returns true.
 * 
 * Note: `predicate` will be called for each entry in reverse.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @param {(undefined|V)=} notSetValue
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.findLast = function(predicate, context, notSetValue) {};

/**
 * Returns the first [key, value] entry for which the `predicate` returns true.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @param {(undefined|V)=} notSetValue
 * @return {(undefined|!Array<?>)}
 */
immutable_.Immutable.Collection.prototype.findEntry = function(predicate, context, notSetValue) {};

/**
 * Returns the last [key, value] entry for which the `predicate`
 * returns true.
 * 
 * Note: `predicate` will be called for each entry in reverse.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @param {(undefined|V)=} notSetValue
 * @return {(undefined|!Array<?>)}
 */
immutable_.Immutable.Collection.prototype.findLastEntry = function(predicate, context, notSetValue) {};

/**
 * Returns the key for which the `predicate` returns true.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {(undefined|K)}
 */
immutable_.Immutable.Collection.prototype.findKey = function(predicate, context) {};

/**
 * Returns the last key for which the `predicate` returns true.
 * 
 * Note: `predicate` will be called for each entry in reverse.
 * @public
 * @param {function(V, K, !immutable.Immutable.Collection): boolean} predicate
 * @param {*=} context
 * @return {(undefined|K)}
 */
immutable_.Immutable.Collection.prototype.findLastKey = function(predicate, context) {};

/**
 * Returns the key associated with the search value, or undefined.
 * @public
 * @param {V} searchValue
 * @return {(undefined|K)}
 */
immutable_.Immutable.Collection.prototype.keyOf = function(searchValue) {};

/**
 * Returns the last key associated with the search value, or undefined.
 * @public
 * @param {V} searchValue
 * @return {(undefined|K)}
 */
immutable_.Immutable.Collection.prototype.lastKeyOf = function(searchValue) {};

/**
 * Returns the maximum value in this collection. If any values are
 * comparatively equivalent, the first one found will be returned.
 * 
 * The `comparator` is used in the same way as `Collection#sort`. If it is not
 * provided, the default comparator is `>`.
 * 
 * When two values are considered equivalent, the first encountered will be
 * returned. Otherwise, `max` will operate independent of the order of input
 * as long as the comparator is commutative. The default comparator `>` is
 * commutative *only* when types do not differ.
 * 
 * If `comparator` returns 0 and either value is NaN, undefined, or null,
 * that value will be returned.
 * @public
 * @param {(undefined|function(V, V): number)=} comparator
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.max = function(comparator) {};

/**
 * Like `max`, but also accepts a `comparatorValueMapper` which allows for
 * comparing by more sophisticated means:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List, } = require('immutable');
 * const l = List([
 *   { name: 'Bob', avgHit: 1 },
 *   { name: 'Max', avgHit: 3 },
 *   { name: 'Lili', avgHit: 2 } ,
 * ]);
 * l.maxBy(i => i.avgHit); // will output { name: 'Max', avgHit: 3 }
 * ```
 * @public
 * @template C
 * @param {function(V, K, !immutable.Immutable.Collection): C} comparatorValueMapper
 * @param {(undefined|function(C, C): number)=} comparator
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.maxBy = function(comparatorValueMapper, comparator) {};

/**
 * Returns the minimum value in this collection. If any values are
 * comparatively equivalent, the first one found will be returned.
 * 
 * The `comparator` is used in the same way as `Collection#sort`. If it is not
 * provided, the default comparator is `<`.
 * 
 * When two values are considered equivalent, the first encountered will be
 * returned. Otherwise, `min` will operate independent of the order of input
 * as long as the comparator is commutative. The default comparator `<` is
 * commutative *only* when types do not differ.
 * 
 * If `comparator` returns 0 and either value is NaN, undefined, or null,
 * that value will be returned.
 * @public
 * @param {(undefined|function(V, V): number)=} comparator
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.min = function(comparator) {};

/**
 * Like `min`, but also accepts a `comparatorValueMapper` which allows for
 * comparing by more sophisticated means:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List, } = require('immutable');
 * const l = List([
 *   { name: 'Bob', avgHit: 1 },
 *   { name: 'Max', avgHit: 3 },
 *   { name: 'Lili', avgHit: 2 } ,
 * ]);
 * l.minBy(i => i.avgHit); // will output { name: 'Bob', avgHit: 1 }
 * ```
 * @public
 * @template C
 * @param {function(V, K, !immutable.Immutable.Collection): C} comparatorValueMapper
 * @param {(undefined|function(C, C): number)=} comparator
 * @return {(undefined|V)}
 */
immutable_.Immutable.Collection.prototype.minBy = function(comparatorValueMapper, comparator) {};

/**
 * True if `iter` includes every value in this Collection.
 * @public
 * @param {!Iterable<V>} iter
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.isSubset = function(iter) {};

/**
 * True if this Collection includes every value in `iter`.
 * @public
 * @param {!Iterable<V>} iter
 * @return {boolean}
 */
immutable_.Immutable.Collection.prototype.isSuperset = function(iter) {};
/**
 * @record
 * @struct
 */
immutable_.Immutable.ValueObject = function() {};

/**
 * True if this and the other Collection have value equality, as defined
 * by `Immutable.is()`.
 * 
 * Note: This is equivalent to `Immutable.is(this, other)`, but provided to
 * allow for chained expressions.
 * @public
 * @param {*} other
 * @return {boolean}
 */
immutable_.Immutable.ValueObject.prototype.equals = function(other) {};

/**
 * Computes and returns the hashed identity for this Collection.
 * 
 * The `hashCode` of a Collection is used to determine potential equality,
 * and is used when adding this to a `Set` or as a key in a `Map`, enabling
 * lookup via a different instance.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { List, Set } = require('immutable');
 * const a = List([ 1, 2, 3 ]);
 * const b = List([ 1, 2, 3 ]);
 * assert.notStrictEqual(a, b); // different instances
 * const set = Set([ a ]);
 * assert.equal(set.has(b), true);
 * ```
 * 
 * Note: hashCode() MUST return a Uint32 number. The easiest way to
 * guarantee this is to return `myHash | 0` from a custom implementation.
 * 
 * If two values have the same `hashCode`, they are [not guaranteed
 * to be equal][Hash Collision]. If two values have different `hashCode`s,
 * they must not be equal.
 * 
 * Note: `hashCode()` is not guaranteed to always be called before
 * `equals()`. Most but not all Immutable.js collections use hash codes to
 * organize their internal data structures, while all Immutable.js
 * collections use equality during lookups.
 * 
 * [Hash Collision]: https://en.wikipedia.org/wiki/Collision_(computer_science)
 * @public
 * @return {number}
 */
immutable_.Immutable.ValueObject.prototype.hashCode = function() {};

/**
 * Deeply converts plain JS objects and arrays to Immutable Maps and Lists.
 * 
 * `fromJS` will convert Arrays and [array-like objects][2] to a List, and
 * plain objects (without a custom prototype) to a Map. [Iterable objects][3]
 * may be converted to List, Map, or Set.
 * 
 * If a `reviver` is optionally provided, it will be called with every
 * collection as a Seq (beginning with the most nested collections
 * and proceeding to the top-level collection itself), along with the key
 * referring to each collection and the parent JS object provided as `this`.
 * For the top level, object, the key will be `""`. This `reviver` is expected
 * to return a new Immutable Collection, allowing for custom conversions from
 * deep JS objects. Finally, a `path` is provided which is the sequence of
 * keys to this value from the starting value.
 * 
 * `reviver` acts similarly to the [same parameter in `JSON.parse`][1].
 * 
 * If `reviver` is not provided, the default behavior will convert Objects
 * into Maps and Arrays into Lists like so:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { fromJS, isKeyed } = require('immutable')
 * function (key, value) {
 *   return isKeyed(value) ? value.toMap() : value.toList()
 * }
 * ```
 * 
 * Accordingly, this example converts native JS data to OrderedMap and List:
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { fromJS, isKeyed } = require('immutable')
 * fromJS({ a: {b: [10, 20, 30]}, c: 40}, function (key, value, path) {
 *   console.log(key, value, path)
 *   return isKeyed(value) ? value.toOrderedMap() : value.toList()
 * })
 * 
 * > "b", [ 10, 20, 30 ], [ "a", "b" ]
 * > "a", {b: [10, 20, 30]}, [ "a" ]
 * > "", {a: {b: [10, 20, 30]}, c: 40}, []
 * ```
 * 
 * Keep in mind, when using JS objects to construct Immutable Maps, that
 * JavaScript Object properties are always strings, even if written in a
 * quote-less shorthand, while Immutable Maps accept keys of any type.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map } = require('immutable')
 * let obj = { 1: "one" };
 * Object.keys(obj); // [ "1" ]
 * assert.equal(obj["1"], obj[1]); // "one" === "one"
 * 
 * let map = Map(obj);
 * assert.notEqual(map.get("1"), map.get(1)); // "one" !== undefined
 * ```
 * 
 * Property access for JavaScript Objects first converts the key to a string,
 * but since Immutable Map keys can be of any type the argument to `get()` is
 * not altered.
 * 
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter
 *      "Using the reviver parameter"
 * [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Indexed_collections#working_with_array-like_objects
 *      "Working with array-like objects"
 * [3]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol
 *      "The iterable protocol"
 * @param {*} jsValue
 * @param {(undefined|function((string|number), ?, (undefined|!Array<(string|number)>)=): *)=} reviver
 * @return {?}
 */
immutable_.Immutable.fromJS = function(jsValue, reviver) {};

/**
 * Value equality check with semantics similar to `Object.is`, but treats
 * Immutable `Collection`s as values, equal if the second `Collection` includes
 * equivalent values.
 * 
 * It's used throughout Immutable when checking for equality, including `Map`
 * key equality and `Set` membership.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { Map, is } = require('immutable')
 * const map1 = Map({ a: 1, b: 1, c: 1 })
 * const map2 = Map({ a: 1, b: 1, c: 1 })
 * assert.equal(map1 !== map2, true)
 * assert.equal(Object.is(map1, map2), false)
 * assert.equal(is(map1, map2), true)
 * ```
 * 
 * `is()` compares primitive types like strings and numbers, Immutable.js
 * collections like `Map` and `List`, but also any custom object which
 * implements `ValueObject` by providing `equals()` and `hashCode()` methods.
 * 
 * Note: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same
 * value, matching the behavior of ES6 Map key equality.
 * @param {*} first
 * @param {*} second
 * @return {boolean}
 */
immutable_.Immutable.is = function(first, second) {};

/**
 * The `hash()` function is an important part of how Immutable determines if
 * two values are equivalent and is used to determine how to store those
 * values. Provided with any value, `hash()` will return a 31-bit integer.
 * 
 * When designing Objects which may be equal, it's important that when a
 * `.equals()` method returns true, that both values `.hashCode()` method
 * return the same value. `hash()` may be used to produce those values.
 * 
 * For non-Immutable Objects that do not provide a `.hashCode()` functions
 * (including plain Objects, plain Arrays, Date objects, etc), a unique hash
 * value will be created for each *instance*. That is, the create hash
 * represents referential equality, and not value equality for Objects. This
 * ensures that if that Object is mutated over time that its hash code will
 * remain consistent, allowing Objects to be used as keys and values in
 * Immutable.js collections.
 * 
 * Note that `hash()` attempts to balance between speed and avoiding
 * collisions, however it makes no attempt to produce secure hashes.
 * 
 * *New in Version 4.0*
 * @param {*} value
 * @return {number}
 */
immutable_.Immutable.hash = function(value) {};

/**
 * True if `maybeImmutable` is an Immutable Collection or Record.
 * 
 * Note: Still returns true even if the collections is within a `withMutations()`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isImmutable, Map, List, Stack } = require('immutable');
 * isImmutable([]); // false
 * isImmutable({}); // false
 * isImmutable(Map()); // true
 * isImmutable(List()); // true
 * isImmutable(Stack()); // true
 * isImmutable(Map().asMutable()); // true
 * ```
 * @param {*} maybeImmutable
 * @return {boolean}
 */
immutable_.Immutable.isImmutable = function(maybeImmutable) {};

/**
 * True if `maybeCollection` is a Collection, or any of its subclasses.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isCollection, Map, List, Stack } = require('immutable');
 * isCollection([]); // false
 * isCollection({}); // false
 * isCollection(Map()); // true
 * isCollection(List()); // true
 * isCollection(Stack()); // true
 * ```
 * @param {*} maybeCollection
 * @return {boolean}
 */
immutable_.Immutable.isCollection = function(maybeCollection) {};

/**
 * True if `maybeKeyed` is a Collection.Keyed, or any of its subclasses.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isKeyed, Map, List, Stack } = require('immutable');
 * isKeyed([]); // false
 * isKeyed({}); // false
 * isKeyed(Map()); // true
 * isKeyed(List()); // false
 * isKeyed(Stack()); // false
 * ```
 * @param {*} maybeKeyed
 * @return {boolean}
 */
immutable_.Immutable.isKeyed = function(maybeKeyed) {};

/**
 * True if `maybeIndexed` is a Collection.Indexed, or any of its subclasses.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isIndexed, Map, List, Stack, Set } = require('immutable');
 * isIndexed([]); // false
 * isIndexed({}); // false
 * isIndexed(Map()); // false
 * isIndexed(List()); // true
 * isIndexed(Stack()); // true
 * isIndexed(Set()); // false
 * ```
 * @param {*} maybeIndexed
 * @return {boolean}
 */
immutable_.Immutable.isIndexed = function(maybeIndexed) {};

/**
 * True if `maybeAssociative` is either a Keyed or Indexed Collection.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isAssociative, Map, List, Stack, Set } = require('immutable');
 * isAssociative([]); // false
 * isAssociative({}); // false
 * isAssociative(Map()); // true
 * isAssociative(List()); // true
 * isAssociative(Stack()); // true
 * isAssociative(Set()); // false
 * ```
 * @param {*} maybeAssociative
 * @return {boolean}
 */
immutable_.Immutable.isAssociative = function(maybeAssociative) {};

/**
 * True if `maybeOrdered` is a Collection where iteration order is well
 * defined. True for Collection.Indexed as well as OrderedMap and OrderedSet.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { isOrdered, Map, OrderedMap, List, Set } = require('immutable');
 * isOrdered([]); // false
 * isOrdered({}); // false
 * isOrdered(Map()); // false
 * isOrdered(OrderedMap()); // true
 * isOrdered(List()); // true
 * isOrdered(Set()); // false
 * ```
 * @param {*} maybeOrdered
 * @return {boolean}
 */
immutable_.Immutable.isOrdered = function(maybeOrdered) {};

/**
 * True if `maybeValue` is a JavaScript Object which has *both* `equals()`
 * and `hashCode()` methods.
 * 
 * Any two instances of *value objects* can be compared for value equality with
 * `Immutable.is()` and can be used as keys in a `Map` or members in a `Set`.
 * @param {*} maybeValue
 * @return {boolean}
 */
immutable_.Immutable.isValueObject = function(maybeValue) {};

/**
 * True if `maybeSeq` is a Seq.
 * @param {*} maybeSeq
 * @return {boolean}
 */
immutable_.Immutable.isSeq = function(maybeSeq) {};

/**
 * True if `maybeList` is a List.
 * @param {*} maybeList
 * @return {boolean}
 */
immutable_.Immutable.isList = function(maybeList) {};

/**
 * True if `maybeMap` is a Map.
 * 
 * Also true for OrderedMaps.
 * @param {*} maybeMap
 * @return {boolean}
 */
immutable_.Immutable.isMap = function(maybeMap) {};

/**
 * True if `maybeOrderedMap` is an OrderedMap.
 * @param {*} maybeOrderedMap
 * @return {boolean}
 */
immutable_.Immutable.isOrderedMap = function(maybeOrderedMap) {};

/**
 * True if `maybeStack` is a Stack.
 * @param {*} maybeStack
 * @return {boolean}
 */
immutable_.Immutable.isStack = function(maybeStack) {};

/**
 * True if `maybeSet` is a Set.
 * 
 * Also true for OrderedSets.
 * @param {*} maybeSet
 * @return {boolean}
 */
immutable_.Immutable.isSet = function(maybeSet) {};

/**
 * True if `maybeOrderedSet` is an OrderedSet.
 * @param {*} maybeOrderedSet
 * @return {boolean}
 */
immutable_.Immutable.isOrderedSet = function(maybeOrderedSet) {};

/**
 * True if `maybeRecord` is a Record.
 * @param {*} maybeRecord
 * @return {boolean}
 */
immutable_.Immutable.isRecord = function(maybeRecord) {};

/**
 * Returns the value within the provided collection associated with the
 * provided key, or notSetValue if the key is not defined in the collection.
 * 
 * A functional alternative to `collection.get(key)` which will also work on
 * plain Objects and Arrays as an alternative for `collection[key]`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { get } = require('immutable')
 * get([ 'dog', 'frog', 'cat' ], 2) // 'frog'
 * get({ x: 123, y: 456 }, 'x') // 123
 * get({ x: 123, y: 456 }, 'z', 'ifNotSet') // 'ifNotSet'
 * ```
 * @template K, V, NSV, TProps, C
 * @param {?|!Array<V>|C|!Object<string,V>} collection_or_record_or_object
 * @param {K|number|string} key
 * @param {NSV|*=} notSetValue
 * @return {(undefined|V)|(V|NSV)|?}
 */
immutable_.Immutable.get = function(collection_or_record_or_object, key, notSetValue) {};

/**
 * Returns true if the key is defined in the provided collection.
 * 
 * A functional alternative to `collection.has(key)` which will also work with
 * plain Objects and Arrays as an alternative for
 * `collection.hasOwnProperty(key)`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { has } = require('immutable')
 * has([ 'dog', 'frog', 'cat' ], 2) // true
 * has([ 'dog', 'frog', 'cat' ], 5) // false
 * has({ x: 123, y: 456 }, 'x') // true
 * has({ x: 123, y: 456 }, 'z') // false
 * ```
 * @param {!Object} collection
 * @param {*} key
 * @return {boolean}
 */
immutable_.Immutable.has = function(collection, key) {};

/**
 * Returns a copy of the collection with the value at key removed.
 * 
 * A functional alternative to `collection.remove(key)` which will also work
 * with plain Objects and Arrays as an alternative for
 * `delete collectionCopy[key]`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { remove } = require('immutable')
 * const originalArray = [ 'dog', 'frog', 'cat' ]
 * remove(originalArray, 1) // [ 'dog', 'cat' ]
 * console.log(originalArray) // [ 'dog', 'frog', 'cat' ]
 * const originalObject = { x: 123, y: 456 }
 * remove(originalObject, 'x') // { y: 456 }
 * console.log(originalObject) // { x: 123, y: 456 }
 * ```
 * @template K, C, TProps
 * @param {C} collection
 * @param {K|number} key
 * @return {C}
 */
immutable_.Immutable.remove = function(collection, key) {};

/**
 * Returns a copy of the collection with the value at key set to the provided
 * value.
 * 
 * A functional alternative to `collection.set(key, value)` which will also
 * work with plain Objects and Arrays as an alternative for
 * `collectionCopy[key] = value`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { set } = require('immutable')
 * const originalArray = [ 'dog', 'frog', 'cat' ]
 * set(originalArray, 1, 'cow') // [ 'dog', 'cow', 'cat' ]
 * console.log(originalArray) // [ 'dog', 'frog', 'cat' ]
 * const originalObject = { x: 123, y: 456 }
 * set(originalObject, 'x', 789) // { x: 789, y: 456 }
 * console.log(originalObject) // { x: 123, y: 456 }
 * ```
 * @template K, V, C, TProps
 * @param {C} collection_or_record_or_object
 * @param {K|number|string} key
 * @param {V|?} value
 * @return {C}
 */
immutable_.Immutable.set = function(collection_or_record_or_object, key, value) {};

/**
 * Returns a copy of the collection with the value at key set to the result of
 * providing the existing value to the updating function.
 * 
 * A functional alternative to `collection.update(key, fn)` which will also
 * work with plain Objects and Arrays as an alternative for
 * `collectionCopy[key] = fn(collection[key])`.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { update } = require('immutable')
 * const originalArray = [ 'dog', 'frog', 'cat' ]
 * update(originalArray, 1, val => val.toUpperCase()) // [ 'dog', 'FROG', 'cat' ]
 * console.log(originalArray) // [ 'dog', 'frog', 'cat' ]
 * const originalObject = { x: 123, y: 456 }
 * update(originalObject, 'x', val => val * 6) // { x: 738, y: 456 }
 * console.log(originalObject) // { x: 123, y: 456 }
 * ```
 * @template K, V, C, NSV, TProps
 * @param {C|!Array<V>} collection_or_record_or_object
 * @param {K|number} key
 * @param {function((undefined|V)): V|NSV|function(?): ?|function(V): V} updater_or_notSetValue
 * @param {function((V|NSV)): V|function((NSV|?)): ?=} updater
 * @return {C|!Array<V>|!Object<string,V>}
 */
immutable_.Immutable.update = function(collection_or_record_or_object, key, updater_or_notSetValue, updater) {};

/**
 * Returns the value at the provided key path starting at the provided
 * collection, or notSetValue if the key path is not defined.
 * 
 * A functional alternative to `collection.getIn(keypath)` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { getIn } = require('immutable')
 * getIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // 123
 * getIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p'], 'ifNotSet') // 'ifNotSet'
 * ```
 * @param {*} collection
 * @param {!Iterable<*>} keyPath
 * @param {*=} notSetValue
 * @return {*}
 */
immutable_.Immutable.getIn = function(collection, keyPath, notSetValue) {};

/**
 * Returns true if the key path is defined in the provided collection.
 * 
 * A functional alternative to `collection.hasIn(keypath)` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { hasIn } = require('immutable')
 * hasIn({ x: { y: { z: 123 }}}, ['x', 'y', 'z']) // true
 * hasIn({ x: { y: { z: 123 }}}, ['x', 'q', 'p']) // false
 * ```
 * @param {*} collection
 * @param {!Iterable<*>} keyPath
 * @return {boolean}
 */
immutable_.Immutable.hasIn = function(collection, keyPath) {};

/**
 * Returns a copy of the collection with the value at the key path removed.
 * 
 * A functional alternative to `collection.removeIn(keypath)` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { removeIn } = require('immutable')
 * const original = { x: { y: { z: 123 }}}
 * removeIn(original, ['x', 'y', 'z']) // { x: { y: {}}}
 * console.log(original) // { x: { y: { z: 123 }}}
 * ```
 * @template C
 * @param {C} collection
 * @param {!Iterable<*>} keyPath
 * @return {C}
 */
immutable_.Immutable.removeIn = function(collection, keyPath) {};

/**
 * Returns a copy of the collection with the value at the key path set to the
 * provided value.
 * 
 * A functional alternative to `collection.setIn(keypath)` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { setIn } = require('immutable')
 * const original = { x: { y: { z: 123 }}}
 * setIn(original, ['x', 'y', 'z'], 456) // { x: { y: { z: 456 }}}
 * console.log(original) // { x: { y: { z: 123 }}}
 * ```
 * @template C
 * @param {C} collection
 * @param {!Iterable<*>} keyPath
 * @param {*} value
 * @return {C}
 */
immutable_.Immutable.setIn = function(collection, keyPath, value) {};

/**
 * Returns a copy of the collection with the value at key path set to the
 * result of providing the existing value to the updating function.
 * 
 * A functional alternative to `collection.updateIn(keypath)` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { updateIn } = require('immutable')
 * const original = { x: { y: { z: 123 }}}
 * updateIn(original, ['x', 'y', 'z'], val => val * 6) // { x: { y: { z: 738 }}}
 * console.log(original) // { x: { y: { z: 123 }}}
 * ```
 * @template C
 * @param {C} collection
 * @param {!Iterable<*>} keyPath
 * @param {function(*): *|*} updater_or_notSetValue
 * @param {function(*): *=} updater
 * @return {C}
 */
immutable_.Immutable.updateIn = function(collection, keyPath, updater_or_notSetValue, updater) {};

/**
 * Returns a copy of the collection with the remaining collections merged in.
 * 
 * A functional alternative to `collection.merge()` which will also work with
 * plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { merge } = require('immutable')
 * const original = { x: 123, y: 456 }
 * merge(original, { y: 789, z: 'abc' }) // { x: 123, y: 789, z: 'abc' }
 * console.log(original) // { x: 123, y: 456 }
 * ```
 * @template C
 * @param {C} collection
 * @param {...(!Iterable<*>|!Iterable<!Array<?>>|!Object<string,*>)} collections
 * @return {C}
 */
immutable_.Immutable.merge = function(collection, collections) {};

/**
 * Returns a copy of the collection with the remaining collections merged in,
 * calling the `merger` function whenever an existing value is encountered.
 * 
 * A functional alternative to `collection.mergeWith()` which will also work
 * with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { mergeWith } = require('immutable')
 * const original = { x: 123, y: 456 }
 * mergeWith(
 *   (oldVal, newVal) => oldVal + newVal,
 *   original,
 *   { y: 789, z: 'abc' }
 * ) // { x: 123, y: 1245, z: 'abc' }
 * console.log(original) // { x: 123, y: 456 }
 * ```
 * @template C
 * @param {function(*, *, *): *} merger
 * @param {C} collection
 * @param {...(!Iterable<*>|!Iterable<!Array<?>>|!Object<string,*>)} collections
 * @return {C}
 */
immutable_.Immutable.mergeWith = function(merger, collection, collections) {};

/**
 * Like `merge()`, but when two compatible collections are encountered with
 * the same key, it merges them as well, recursing deeply through the nested
 * data. Two collections are considered to be compatible (and thus will be
 * merged together) if they both fall into one of three categories: keyed
 * (e.g., `Map`s, `Record`s, and objects), indexed (e.g., `List`s and
 * arrays), or set-like (e.g., `Set`s). If they fall into separate
 * categories, `mergeDeep` will replace the existing collection with the
 * collection being merged in. This behavior can be customized by using
 * `mergeDeepWith()`.
 * 
 * Note: Indexed and set-like collections are merged using
 * `concat()`/`union()` and therefore do not recurse.
 * 
 * A functional alternative to `collection.mergeDeep()` which will also work
 * with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { mergeDeep } = require('immutable')
 * const original = { x: { y: 123 }}
 * mergeDeep(original, { x: { z: 456 }}) // { x: { y: 123, z: 456 }}
 * console.log(original) // { x: { y: 123 }}
 * ```
 * @template C
 * @param {C} collection
 * @param {...(!Iterable<*>|!Iterable<!Array<?>>|!Object<string,*>)} collections
 * @return {C}
 */
immutable_.Immutable.mergeDeep = function(collection, collections) {};

/**
 * Like `mergeDeep()`, but when two non-collections or incompatible
 * collections are encountered at the same key, it uses the `merger` function
 * to determine the resulting value. Collections are considered incompatible
 * if they fall into separate categories between keyed, indexed, and set-like.
 * 
 * A functional alternative to `collection.mergeDeepWith()` which will also
 * work with plain Objects and Arrays.
 * 
 * <!-- runkit:activate -->
 * ```js
 * const { mergeDeepWith } = require('immutable')
 * const original = { x: { y: 123 }}
 * mergeDeepWith(
 *   (oldVal, newVal) => oldVal + newVal,
 *   original,
 *   { x: { y: 456 }}
 * ) // { x: { y: 579 }}
 * console.log(original) // { x: { y: 123 }}
 * ```
 * @template C
 * @param {function(*, *, *): *} merger
 * @param {C} collection
 * @param {...(!Iterable<*>|!Iterable<!Array<?>>|!Object<string,*>)} collections
 * @return {C}
 */
immutable_.Immutable.mergeDeepWith = function(merger, collection, collections) {};
/**
 * export = Immutable
 * @const
 */
var immutable = immutable_.Immutable;
